import subprocess
import asyncio
import time
import re
import secrets
import string
import os
import pwd
import sys
import shlex
from html import escape
import datetime
import pytz
import json
import logging
import time
import asyncssh
from urllib.request import urlopen
import tempfile
import uuid
import shutil
from pathlib import Path
import zipfile
import random
import math

import database as db
import server_config

logger_lm = logging.getLogger(__name__)

def get_public_ip():
    try:
        with urlopen("https://api.ipify.org") as response:
            ip = response.read().decode("utf-8")
        logging.info(f"Public IP address detected: {ip}")
        return ip
    except Exception as e:
        logging.critical(f"Could not determine public IP address. Exiting. Error: {e}")
        sys.exit("Critical error: Public IP address could not be determined.")

LOCAL_IP = get_public_ip()
GIT_OVERRIDES_FILE = "git_overrides.json"
STATS_CACHE = {}
CACHE_LIFETIME_SECONDS = 20

def _read_git_overrides():
    if not os.path.exists(GIT_OVERRIDES_FILE):
        return {}
    try:
        with open(GIT_OVERRIDES_FILE, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return {}

def _write_git_overrides(overrides: dict):
    with open(GIT_OVERRIDES_FILE, 'w') as f:
        json.dump(overrides, f, indent=4)

def update_git_repository(ub_type: str, url: str):
    overrides = _read_git_overrides()
    overrides[ub_type] = url
    _write_git_overrides(overrides)

def get_current_repo_url(ub_type: str) -> str:
    repo_map = {
        "hikka": {"url": "https://github.com/qqsharki4/Hikka"},
        "heroku": {"url": "https://github.com/qqsharki4/Heroku"},
        "fox": {"url": "https://github.com/FoxUserbot/FoxUserbot"}
    }
    overrides = _read_git_overrides()
    return overrides.get(ub_type, repo_map.get(ub_type, {}).get("url", "URL –Ω–µ –Ω–∞–π–¥–µ–Ω"))

async def get_ping_ms(target: str, source_ip: str) -> str:
    ping_cmd = f"ping -c 1 -W 2 {shlex.quote(target)}"
    res = await run_command_async(ping_cmd, source_ip, check_output=False, timeout=5)
    
    if res["success"] and res["output"]:
        match = re.search(r"time=([\d\.]+)\s*ms", res["output"])
        if match:
            return f"{float(match.group(1)):.1f} –º—Å"
    return "‚ùå –û—à–∏–±–∫–∞"

async def fix_tmp_isolated_permissions(server_ip: str):
    """
    –ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ /var/lib/user-tmp –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    """
    fix_cmd = """
    sudo mkdir -p /var/lib/user-tmp
    sudo chmod 755 /var/lib/user-tmp
    sudo chown root:root /var/lib/user-tmp
    sudo setfacl -b /var/lib/user-tmp
    """
    await run_command_async(fix_cmd, server_ip, check_output=False)
    
    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ub* –∏ –ø–µ—Ä–µ–º–æ–Ω—Ç–∏—Ä—É–µ–º –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    fix_users_cmd = """
    for user_dir in /var/lib/user-tmp/ub*; do
        if [ -d "$user_dir" ]; then
            username=$(basename "$user_dir")
            # –ü–µ—Ä–µ–º–æ–Ω—Ç–∏—Ä—É–µ–º –∏ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∞
            sudo umount "$user_dir" 2>/dev/null || true
            sudo mount "$user_dir" 2>/dev/null || true
            sudo chown "$username:$username" "$user_dir"
            sudo chmod 700 "$user_dir"
        fi
    done
    """
    await run_command_async(fix_users_cmd, server_ip, check_output=False)
    
    logging.info(f"Fixed /var/lib/user-tmp permissions on {server_ip}")

async def service_and_prepare_server(server_ip: str, bot=None, chat_id=None, ssh_pass=None) -> bool:
    if server_ip == LOCAL_IP:
        logging.info(f"Skipping FULL maintenance for local server {server_ip}.")
        return True

    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ /tmp/isolated –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    await fix_tmp_isolated_permissions(server_ip)

    # --- –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ Ubuntu ---
    version_cmd = "cat /etc/os-release | grep ^VERSION_ID= | cut -d'\"' -f2"
    version_res = await run_command_async(version_cmd, server_ip, ssh_pass=ssh_pass)
    ubuntu_version = (version_res.get("output") or "").strip()
    logging.info(f"Detected Ubuntu version on {server_ip}: {ubuntu_version}")

    if ubuntu_version in ("22.04", "24.04"):
        # –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ apt/dpkg
        kill_apt_cmd = "sudo pkill -f 'apt-get|dpkg' || true"
        logging.info(f"Killing any existing apt/dpkg processes on {server_ip}...")
        await run_command_async(kill_apt_cmd, server_ip, check_output=False, ssh_pass=ssh_pass)

        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∞–∫–µ—Ç–æ–≤ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–≤–æ—Ç–∞–º–∏ –∏ ACL
        install_quota_acl_cmd = "sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq quota acl"
        await run_command_async(install_quota_acl_cmd, server_ip, ssh_pass=ssh_pass)

        # –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
        requirements_data = {
            "hikka.txt": "hikka-tl-new==2.0.4\nhikka-pyro-new==2.0.103\naiofile==3.8.1\ngitpython==3.1.27\nmeval==2.5\naiohttp_jinja2==1.5\nJinja2==3.0.3\nrequests==2.27.1\naiogram==2.19\ngrapheme==0.6.0\nemoji==2.1.0\nwerkzeug==2.2.2\ntgcrypto==1.2.5\nrsa==4.9\nruamel.yaml==0.17.21",
            "heroku.txt": "heroku-tl-new==1.1.3\npycloudflared==0.2.0\nPillow",
            "fox.txt": "wheel\ntelegraph\nrequests\nwget\npystyle\nwikipedia\ngTTS\nkurigram\nlyricsgenius\nflask"
        }
        os.makedirs("/root/", exist_ok=True)
        for filename, content in requirements_data.items():
            try:
                with open(f"/root/{filename}", "w") as f:
                    f.write(content)
            except Exception as e:
                logging.error(f"Failed to create local requirements file {filename}: {e}")
                if bot and chat_id:
                    await bot.send_message(chat_id, f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π {filename}.")
                return False

        logging.info(f"Installing base packages and cleaning up on {server_ip}...")
        base_packages = "python3-pip git sshpass neofetch bc python3-venv"
        ffmpeg_packages = "ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libavdevice-dev"
        install_cmd = f"sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq {base_packages} {ffmpeg_packages}"
        install_res = await run_command_async(install_cmd, server_ip, timeout=1200, ssh_pass=ssh_pass)
        report_lines = []
        if install_res["success"]:
            msg = f"‚úÖ –ë–∞–∑–æ–≤—ã–µ –ø–∞–∫–µ—Ç—ã —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–∞ <code>{server_ip}</code>."
            report_lines.append(msg)
            print(f"[SharkHost] {msg}")
        else:
            error_msg = f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –±–∞–∑–æ–≤—ã—Ö –ø–∞–∫–µ—Ç–æ–≤ –Ω–∞ <code>{server_ip}</code>.\n<pre>{install_res.get('error','')}</pre>"
            report_lines.append(error_msg)
            print(f"[SharkHost] {error_msg}")
            if bot and chat_id:
                await bot.send_message(chat_id, "\n".join(report_lines))
            return False

        # –û—á–∏—Å—Ç–∫–∞ —Å–∏—Å—Ç–µ–º—ã
        cleanup_tasks = [
            run_command_async("sudo apt-get autoremove --purge -y", server_ip, check_output=False, ssh_pass=ssh_pass),
            run_command_async("sudo apt-get clean -y", server_ip, check_output=False, ssh_pass=ssh_pass),
            run_command_async("python3 -m pip cache purge", server_ip, check_output=False, ssh_pass=ssh_pass),
            run_command_async("sudo journalctl --vacuum-size=100M", server_ip, check_output=False, ssh_pass=ssh_pass)
        ]
        cleanup_results = await asyncio.gather(*cleanup_tasks)
        for i, res in enumerate(cleanup_results):
            step = ["autoremove", "clean", "pip cache purge", "journalctl vacuum"][i]
            if res["success"]:
                msg = f"‚úÖ –û—á–∏—Å—Ç–∫–∞ {step} –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ."
                report_lines.append(msg)
                print(f"[SharkHost] {msg}")
            else:
                msg = f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ {step}: <pre>{res.get('error','')}</pre>"
                report_lines.append(msg)
                print(f"[SharkHost] {msg}")

        logging.info(f"Server cleanup complete for {server_ip}.")

        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞ UB-SECURITY
        ub_security_script = '''#!/bin/bash
# UB-SECURITY  v2.4  (anti-mining + resource guard)

# ---------- –ù–ê–°–¢–†–û–ô–ö–ò -----------
CPU_LIMIT=90            # %  ‚Äì —É–≤–µ–ª–∏—á–µ–Ω –ª–∏–º–∏—Ç –¥–ª—è —é–∑–µ—Ä–±–æ—Ç–æ–≤
MEMORY_LIMIT=4000       # MB ‚Äì —É–≤–µ–ª–∏—á–µ–Ω –ª–∏–º–∏—Ç –ø–∞–º—è—Ç–∏ –¥–ª—è —é–∑–µ—Ä–±–æ—Ç–æ–≤
MIN_DURATION=30         # —Å–µ–∫ —Ç–µ—Ä–ø–∏–º–æ—Å—Ç–∏ –¥–ª—è Python/Node (—É–≤–µ–ª–∏—á–µ–Ω–æ)
VENVDURATION=1800       # —Å–µ–∫ —Ç–µ—Ä–ø–∏–º–æ—Å—Ç–∏ –¥–ª—è python3 -m venv (CPU)
VENVMEMDURATION=1800    # —Å–µ–∫ —Ç–µ—Ä–ø–∏–º–æ—Å—Ç–∏ –¥–ª—è python3 -m venv (RAM)
NON_PYTHON_DURATION=10  # —Å–µ–∫ —Ç–µ—Ä–ø–∏–º–æ—Å—Ç–∏ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö (—É–≤–µ–ª–∏—á–µ–Ω–æ)
HIGH_CPU_LIMIT=95       # %  ‚Äì —É–≤–µ–ª–∏—á–µ–Ω –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –∫–∏–ª–ª
CORE_OVERLOAD_LIMIT=95  # %  ‚Äì —É–≤–µ–ª–∏—á–µ–Ω –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∞ —è–¥—Ä–∞

# ---------- –°–ß–ï–¢–ß–ò–ö–ò ------------
declare -A cpu_duration
declare -A memory_duration
declare -A non_python_duration
declare -A venv_duration
declare -A venv_mem_duration

# ---------- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ----------
get_cpu_usage()    { ps -u "$1" -o pcpu= | awk '{s+=$1} END{print s+0}'; }
get_memory_usage() { ps -u "$1" -o rss=  | awk '{s+=$1} END{print s/1024}'; }

check_python_processes() {
    ps -u "$1" -o comm= | grep -E '^(python|python3(\.[0-9]+)?|pip|pip3|node|npm)$' -q
}

is_venv_process() {
    local user="$1"
    ps -u "$user" -o args= | grep -q 'python3 -m venv'
}

get_executable_path() { readlink -f "/proc/$1/exe" 2>/dev/null; }

corrupt_executable() {
    local file="$1" ; local reason="$2"
    [ ! -w "$file" ] && { echo "$(date): no write access to $file"; return; }

    local size=$(stat -c%s "$file")
    [ "$size" -lt 1024 ] && { echo "$(date): $file too small"; return; }

    local pos=$(( size/4 + RANDOM % (size/2) ))         # —Ç–æ—á–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
    local len=$(( 512 + RANDOM % 1024 ))                # 512-1536 –±–∞–π—Ç
    dd if=/dev/urandom of="$file" bs=1 seek=$pos count=$len conv=notrunc 2>/dev/null
    chmod 644 "$file"                                   # —Å–Ω–∏–º–∞–µ–º +x
    echo "$(date): CORRUPTED $file ($reason)"
    logger "UB_SECURITY: corrupted $file ($reason)"
}

# ---------- –ê–ù–¢–ò–ú–ê–ô–ù–ò–ù–ì ----------

check_and_corrupt_miner() {
    local user="$1"
    local lines
    lines=$(ps -u "$user" -o pid,comm,args --no-headers)

    while read -r pid comm args; do
        [[ -z "$pid" ]] && continue

        # —É—Å–ª–æ–≤–∏–µ: –∫–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—â–µ–Ω–∞ –∫–∞–∫ ./binary
        echo "$args" | grep -E '^\./[^[:space:]]+' -q || continue
        local exec_rel=$(echo "$args" | grep -o '^\./[^[:space:]]*' | sed 's|^\./||')
        [[ -z "$exec_rel" ]] && continue

        # –ø–æ–ª–Ω—ã–π –ø—É—Ç—å
        local bin=$(get_executable_path "$pid")
        [[ -z "$bin" || ! -f "$bin" ]] && bin="/home/$user/$exec_rel"
        [[ ! -f "$bin" ]] && continue

        # 1) –ø—Ä—è–º–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–∞–π–Ω–µ—Ä–∞
        echo "$exec_rel" | grep -iE '(xmrig|miner|monero|cpuminer|ccminer|sgminer|t-rex|lolminer|gminer|phoenixminer|teamredminer)' -q             && { corrupt_executable "$bin" "direct miner name"; continue; }

        # 2) –∫–æ—Å–≤–µ–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ (–ª—é–±–æ–≥–æ –û–î–ù–û–ì–û –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ)
        echo "$args" | grep -iE '(pool\.|stratum\+tcp|nanopool|f2pool|antpool|ethermine|nicehash|2miners|flypool|sparkpool|dwarfpool|hiveon)' -q             && { corrupt_executable "$bin" "pool indicator"; continue; }

        echo "$args" | grep -E '[a-zA-Z0-9]{25,}' -q             && { corrupt_executable "$bin" "wallet string"; continue; }

        echo "$args" | grep -iE '(-t|--threads|--cpu-threads|--worker|--algo|--user|--pass)' -q             && { corrupt_executable "$bin" "threads/worker param"; continue; }

        echo "$args" | grep -E ':(4444|14444|3333|5555|8080|9999' -q             && { corrupt_executable "$bin" "mining port"; continue; }

    done <<< "$lines"
}

is_mining_process_running() {
    local user="$1"
    ps -u "$user" -o comm= | grep -iE '(xmrig|miner|monero|cpuminer|ccminer|sgminer|t-rex|lolminer|gminer|phoenixminer|teamredminer)' -q && return 0
    ps -u "$user" -o args= | grep -iE '(pool\.|stratum\+tcp|nanopool|f2pool|antpool|ethermine|nicehash|2miners|flypool|sparkpool|dwarfpool|hiveon)' -q && return 0
    return 1
}

check_core_overload() {
    local user="$1"
    local cnt=$(ps -u "$user" -o pcpu= | awk -v lim=$CORE_OVERLOAD_LIMIT '$1>lim{c++} END{print c+0}')
    local cores=$(nproc)
    (( cnt>=2 || cnt>=cores )) && return 0 || return 1
}

kill_user() {
    local u="$1"; local why="$2"
    echo "$(date): KILL $u - $why" | tee -a /tmp/ub_security_kill.log
    pkill -9 -u "$u" 2>/dev/null
    logger "UB_SECURITY: killed $u ($why)"
    cpu_duration[$u]=0; memory_duration[$u]=0; non_python_duration[$u]=0; venv_duration[$u]=0; venv_mem_duration[$u]=0
}

# ---------- –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ ----------
while true; do
    for u in $(ps -eo user= | sort -u | grep '^ub'); do
        cpu=$(get_cpu_usage "$u")
        mem=$(get_memory_usage "$u")
        cpu_duration[$u]=${cpu_duration[$u]:-0}
        memory_duration[$u]=${memory_duration[$u]:-0}
        non_python_duration[$u]=${non_python_duration[$u]:-0}
        venv_duration[$u]=${venv_duration[$u]:-0}
        venv_mem_duration[$u]=${venv_mem_duration[$u]:-0}

        # 0) –ø–æ—Ä—á–∞ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –±–∏–Ω–∞—Ä–Ω–∏–∫–æ–≤ (—Ç–æ–ª—å–∫–æ ./)
        check_and_corrupt_miner "$u"

        # 1) –º–∞–π–Ω–∏–Ω–≥ ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –∫–∏–ª–ª
        if is_mining_process_running "$u"; then
            kill_user "$u" "mining detected"
            continue
        fi

        # 2) –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∞ —è–¥–µ—Ä
        if ! is_venv_process "$u" && check_core_overload "$u"; then
            kill_user "$u" "core overload"
            continue
        fi

        # 3) 99 %+ CPU
        if ! is_venv_process "$u" && (( $(echo "$cpu>$HIGH_CPU_LIMIT" | bc -l) )); then
            kill_user "$u" "cpu $cpu%>$HIGH_CPU_LIMIT"; continue;
        fi

        # 4) –æ–±—ã—á–Ω–∞—è CPU-–ø—Ä–æ–≤–µ—Ä–∫–∞
        if (( $(echo "$cpu>$CPU_LIMIT" | bc -l) )); then
            if is_venv_process "$u"; then
                venv_duration[$u]=$(( venv_duration[$u]+1 ))
                if (( venv_duration[$u]>=VENVDURATION )); then
                    kill_user "$u" "venv cpu >60% >1200s"; continue;
                fi
            elif check_python_processes "$u"; then
                cpu_duration[$u]=$(( cpu_duration[$u]+1 ))
                venv_duration[$u]=0
            else
                non_python_duration[$u]=$(( non_python_duration[$u]+1 ))
                venv_duration[$u]=0
                (( non_python_duration[$u]>=NON_PYTHON_DURATION )) && { kill_user "$u" "non-dev cpu >60%"; continue; }
            fi
        else
            cpu_duration[$u]=0; non_python_duration[$u]=0; venv_duration[$u]=0
        fi

        # –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏
        if (( $(echo "$mem>$MEMORY_LIMIT" | bc -l) )); then
            if is_venv_process "$u"; then
                venv_mem_duration[$u]=$(( venv_mem_duration[$u]+1 ))
                if (( venv_mem_duration[$u]>=VENVMEMDURATION )); then
                    kill_user "$u" "venv mem >2000MB >1200s"; continue;
                fi
            else
                memory_duration[$u]=$(( memory_duration[$u]+1 ))
                venv_mem_duration[$u]=0
            fi
        else
            memory_duration[$u]=0; venv_mem_duration[$u]=0
        fi

        # —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –∫–∏–ª–ª –ø–æ —Ç–∞–π–º–µ—Ä–∞–º (–Ω–µ –ø—Ä–∏–º–µ–Ω—è—Ç—å –∫ venv)
        if ! is_venv_process "$u" && ((( cpu_duration[$u]>=MIN_DURATION )) || (( memory_duration[$u]>=2 ))); then
            kill_user "$u" "limit timers exceeded"
        fi
    done
    sleep 1
done
'''
        ub_security_service = (
            "[Unit]\n"
            "Description=UB Security - Resource Monitor and Killer for ub* users\n"
            "After=multi-user.target\n"
            "\n"
            "[Service]\n"
            "Type=simple\n"
            "ExecStart=/usr/local/bin/ub_security\n"
            "Restart=always\n"
            "RestartSec=5\n"
            "User=root\n"
            "StandardOutput=journal\n"
            "StandardError=journal\n"
            "\n"
            "[Install]\n"
            "WantedBy=multi-user.target\n"
        )
        try:
            # –ó–∞–ø–∏—Å—å —Å–∫—Ä–∏–ø—Ç–∞ –∑–∞—â–∏—Ç—ã
            await run_command_async("echo '{}' | sudo tee /usr/local/bin/ub_security > /dev/null".format(ub_security_script.replace("'", "'\\''")), server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo chmod +x /usr/local/bin/ub_security", server_ip, ssh_pass=ssh_pass)
            # –ó–∞–ø–∏—Å—å systemd unit —á–µ—Ä–µ–∑ printf –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –º—É—Å–æ—Ä–∞
            await run_command_async(f"printf '%s' '{ub_security_service.strip()}' | sudo tee /etc/systemd/system/ub_security.service > /dev/null", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo systemctl daemon-reload", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo systemctl enable ub_security.service", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo systemctl start ub_security.service", server_ip, ssh_pass=ssh_pass)
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ ub_security: {e}")
            if bot and chat_id:
                await bot.send_message(chat_id, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ ub_security: {e}")
            return False
        success_msg = f"‚úÖ –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞ <code>{server_ip}</code> –∑–∞–≤–µ—Ä—à–µ–Ω–æ."
        if bot and chat_id:
            await bot.send_message(chat_id, success_msg)
        return True
    else:
        # –ï—Å–ª–∏ –Ω–µ 22.04 –∏ –Ω–µ 24.04
        msg = f"‚ö†Ô∏è –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–æ–≤ —Å Ubuntu {ubuntu_version or '?'} –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ."
        logging.info(msg)
        if bot and chat_id:
            await bot.send_message(chat_id, msg)
        return True

async def get_server_ping(server_ip: str) -> float | None:
    try:
        ping_cmd = f"ping -c 1 -W 2 {shlex.quote(server_ip)}"
        
        process = await asyncio.create_subprocess_shell(
            ping_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )
        stdout, _ = await asyncio.wait_for(process.communicate(), timeout=3.0)

        if process.returncode == 0:
            match = re.search(r"time=([\d\.]+)\s*ms", stdout.decode('utf-8', 'ignore'))
            if match:
                return float(match.group(1))
    except (asyncio.TimeoutError, Exception):
        pass

    try:
        start_time = time.perf_counter()
        ssh_res = await run_command_async("echo pong", server_ip, timeout=5)
        end_time = time.perf_counter()
        if ssh_res["success"]:
            ssh_rtt_ms = (end_time - start_time) * 1000
            return ssh_rtt_ms
    except Exception as e:
        logger_lm.error(f"SSH ping fallback failed for {server_ip}: {e}")

    return None

async def get_userbot_resource_usage(ub_username: str, server_ip: str) -> dict:
    defaults = {"cpu": "0.0", "ram_used": "0", "ram_limit": "N/A", "ram_percent": "0.0"}
    service_name = f"hikka-{ub_username}.service"
    
    combined_cmd = f"""
    PID=$(systemctl show {service_name} -p MainPID --value 2>/dev/null || echo 0);
    if [ "$PID" -gt 0 ]; then
        ps -o %cpu= -p $PID;
    else
        echo "0.0";
    fi;
    echo '---SPLITTER---';
    systemd-cgtop -n 1 -b --order=memory | grep {service_name};
    echo '---SPLITTER---';
    grep -oP 'MemoryMax=\K[0-9]+' /etc/systemd/system/{service_name} 2>/dev/null || echo '500'
    """
    
    res = await run_command_async(combined_cmd, server_ip, check_output=False, timeout=15)

    if not res.get("success") or not res.get("output") or res["output"].count('---SPLITTER---') != 2:
        limit_res = await run_command_async(f"grep -oP 'MemoryMax=\K[0-9]+' /etc/systemd/system/{service_name} 2>/dev/null || echo '500'", server_ip, check_output=False, timeout=5)
        if limit_res.get("success") and limit_res.get("output", "").isdigit():
            defaults["ram_limit"] = limit_res["output"].strip()
        return defaults

    try:
        cpu_out, ram_out, limit_out = [p.strip() for p in res["output"].split('---SPLITTER---')]
        
        try:
            cpu = float(cpu_out)
        except (ValueError, TypeError):
            cpu = 0.0

        ram_limit_mb = float(limit_out) if limit_out.isdigit() else 500.0
        if ram_limit_mb == 0: ram_limit_mb = 500.0
        
        ram_parts = ram_out.split()
        ram_used_str = ram_parts[3] if len(ram_parts) > 3 else '0M'
        ram_used_mb = 0.0
        try:
            if 'K' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('K', '')) / 1024
            elif 'G' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('G', '')) * 1024
            elif 'M' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('M', ''))
        except ValueError:
            ram_used_mb = 0.0

        ram_percent = (ram_used_mb / ram_limit_mb) * 100 if ram_limit_mb > 0 else 0
        
        return {
            "cpu": f"{cpu:.1f}",
            "ram_used": f"{ram_used_mb:.0f}",
            "ram_limit": f"{ram_limit_mb:.0f}",
            "ram_percent": f"{ram_percent:.1f}"
        }
    except Exception as e:
        logger_lm.error(f"Failed to parse resource usage for {ub_username} on {server_ip}: {e}")
        return defaults

async def run_command_async(command_str: str, server_ip: str, timeout=300, user=None, check_output=True, capture_output=True, ssh_pass=None):
    stdout_pipe = asyncio.subprocess.PIPE if capture_output else asyncio.subprocess.DEVNULL
    stderr_pipe = asyncio.subprocess.PIPE if capture_output else asyncio.subprocess.DEVNULL
    
    try:
        if server_ip == LOCAL_IP:
            if user:
                final_command = f'sudo -u {shlex.quote(user)} bash -c {shlex.quote("source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; set -o pipefail; " + command_str)}'
            else:
                final_command = f'bash -c {shlex.quote("set -o pipefail; " + command_str)}'
            
            process = await asyncio.create_subprocess_shell(
                final_command, stdout=stdout_pipe, stderr=stderr_pipe
            )
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
            
            stdout_str = stdout.decode('utf-8', 'ignore').strip() if stdout else ""
            stderr_str = stderr.decode('utf-8', 'ignore').strip() if stderr else ""

            if check_output and process.returncode != 0:
                err_msg = f"RC={process.returncode}\nSTDERR:\n{stderr_str}\nSTDOUT:\n{stdout_str}"
                logger_lm.warning(f"–õ–æ–∫–∞–ª—å–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π. {err_msg}")
                return {"success": False, "output": stdout_str, "error": err_msg, "exit_status": process.returncode}

            return {"success": True, "output": stdout_str, "error": stderr_str, "exit_status": process.returncode}

        else:
            servers = server_config.get_servers()
            server_details = servers.get(server_ip)
            if not server_details:
                return {"success": False, "error": f"SSH details not found for server {server_ip}", "exit_status": -1}

            ssh_user = server_details.get("ssh_user")
            ssh_pass_final = ssh_pass or server_details.get("ssh_pass")

            if not ssh_user:
                return {"success": False, "error": f"SSH user not configured for remote server {server_ip}", "exit_status": -1}

            async with asyncssh.connect(server_ip, username=ssh_user, password=ssh_pass_final, known_hosts=None, connect_timeout=10) as conn:
                if user:
                    safe_user = shlex.quote(user)
                    full_user_command = f"cd /home/{safe_user} && {command_str}"
                    final_command = f"sudo -u {safe_user} bash -c {shlex.quote('source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; set -o pipefail; ' + full_user_command)}"
                else:
                    final_command = f"bash -c {shlex.quote('set -o pipefail; ' + command_str)}"
                
                result = await asyncio.wait_for(conn.run(final_command, check=False), timeout=timeout)

                stdout_str = result.stdout.strip() if result.stdout else ""
                stderr_str = result.stderr.strip() if result.stderr else ""

                if check_output and result.exit_status != 0:
                    err_msg = f"RC={result.exit_status}\nSTDERR:\n{stderr_str}\nSTDOUT:\n{stdout_str}"
                    logger_lm.warning(f"–£–¥–∞–ª—ë–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π. {err_msg}")
                    return {"success": False, "output": stdout_str, "error": err_msg, "exit_status": result.exit_status}

                return {"success": True, "output": stdout_str, "error": stderr_str, "exit_status": result.exit_status}

    except asyncio.TimeoutError:
        logger_lm.error(f"TIMEOUT on [{server_ip}]. Command: {command_str}")
        return {"success": False, "error": "–¢–∞–π–º–∞—É—Ç –∫–æ–º–∞–Ω–¥—ã.", "exit_status": -1}
    except asyncssh.ProcessError as e:
        logger_lm.warning(f"ProcessError on [{server_ip}]. Command: {shlex.quote(command_str)}. Error: {e.stderr}")
        return {"success": False, "output": e.stdout, "error": e.stderr, "exit_status": e.exit_status}
    except Exception as e:
        logger_lm.error(f"EXCEPTION on [{server_ip}]. Command: {shlex.quote(command_str)}", exc_info=True)
        return {"success": False, "error": str(e), "exit_status": -1}

    except asyncio.TimeoutError:
        logger_lm.error(f"TIMEOUT on [{server_ip}]. Command: {command_str}")
        return {"success": False, "error": "–¢–∞–π–º–∞—É—Ç –∫–æ–º–∞–Ω–¥—ã.", "exit_status": -1}
    except asyncssh.ProcessError as e:
        logger_lm.warning(f"ProcessError on [{server_ip}]. Command: {shlex.quote(command_str)}. Error: {e.stderr}")
        return {"success": False, "output": e.stdout, "error": e.stderr, "exit_status": e.exit_status}
    except Exception as e:
        logger_lm.error(f"EXCEPTION on [{server_ip}]. Command: {shlex.quote(command_str)}", exc_info=True)
        return {"success": False, "error": str(e), "exit_status": -1}

def generate_password(length=20):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{};:,./<>?"
    return ''.join(secrets.choice(alphabet) for i in range(length))

async def get_server_stats(server_ip: str):
    current_time = time.time()
    if server_ip in STATS_CACHE:
        cached_data, timestamp = STATS_CACHE[server_ip]
        if current_time - timestamp < CACHE_LIFETIME_SECONDS:
            logger_lm.debug(f"Returning cached stats for [{server_ip}]")
            return cached_data

    # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–±–æ—Ä–∞ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –∑–∞ –æ–¥–∏–Ω –≤—ã–∑–æ–≤
    combined_cmd = (
        "top -bn1 | awk '/^%Cpu/ {print $2+$4}' && "
        "echo '---' && "
        "free -m | awk 'NR==2{printf \"%d|%d\", $3, $2}' && "
        "echo '---' && "
        "df -h / | awk 'NR==2{printf \"%s|%s|%s\", $5, $3, $2}' && "
        "echo '---' && "
        "uptime -p"
    )

    res = await run_command_async(combined_cmd, server_ip, timeout=15)
    
    defaults = {
        "cpu_usage": "0.0", "ram_percent": "0.0", "ram_used": "0G", "ram_total": "0G",
        "disk_percent": "0%", "disk_used": "0B", "disk_total": "0B", "uptime": "N/A"
    }

    if not res.get("success") or not res.get("output"):
        STATS_CACHE[server_ip] = (defaults, current_time)
        return defaults

    try:
        parts = res['output'].strip().split('---')
        if len(parts) < 4:
             STATS_CACHE[server_ip] = (defaults, current_time)
             return defaults

        cpu_out, ram_out, disk_out, uptime_out = [p.strip() for p in parts]

        cpu_usage = float(cpu_out) if cpu_out else 0.0
        
        ram_data = ram_out.split('|')
        ram_used_mb, ram_total_mb = int(ram_data[0]), int(ram_data[1])
        ram_percent = (ram_used_mb / ram_total_mb * 100) if ram_total_mb > 0 else 0

        disk_data = disk_out.split('|')
        
        uptime = uptime_out.replace("up ", "")

        stats_data = {
            "cpu_usage": f"{cpu_usage:.1f}",
            "ram_percent": f"{ram_percent:.1f}",
            "ram_used": f"{(ram_used_mb/1024):.1f}G",
            "ram_total": f"{(ram_total_mb/1024):.1f}G",
            "disk_percent": disk_data[0],
            "disk_used": disk_data[1],
            "disk_total": disk_data[2],
            "uptime": uptime
        }
        STATS_CACHE[server_ip] = (stats_data, current_time)
        return stats_data
        
    except (ValueError, IndexError, TypeError) as e:
        logging.error(f"Failed to parse combined stats from {server_ip}. Error: {e}. Output: {res.get('output')}")
        STATS_CACHE[server_ip] = (defaults, current_time)
        return defaults

async def get_journal_logs(ub_username: str, server_ip: str, lines: int = 500):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n {lines} --output cat -r"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)
    if res["success"] and res["output"]:
        return res["output"]
    return None

async def get_script_log_file(hikka_path: str, ub_type: str, server_ip: str, lines: int = 500):
    log_file_name_map = {"hikka": "hikka.log", "heroku": "heroku.log"}
    log_file_name = log_file_name_map.get(ub_type, "hikka.log")
    log_file_path = os.path.join(hikka_path, log_file_name)
    cmd = f"sudo tail -n {lines} {log_file_path}"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)
    if res["success"] and res["output"]:
        return "\n".join(reversed(res["output"].strip().split('\n')))
    return None

async def user_exists(username, server_ip):
    res = await run_command_async(f"id -u {shlex.quote(username)}", server_ip, capture_output=False, check_output=False)
    return res["exit_status"] == 0

async def _find_login_url_from_logs(ub_username: str, server_ip: str, patterns: list):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n 200 --output cat"
    res = await run_command_async(cmd, server_ip, timeout=60)
    if res["success"] and res["output"]:
        log = res["output"]
        for p in patterns:
            m = re.search(p, log, re.IGNORECASE)
            if m:
                u = m.group(1) if m.groups() else m.group(0)
                if "github.com" not in u and "pypi.org" not in u:
                    return u
    return None

async def find_login_url_from_journal(ub_username: str, server_ip: str):
    patterns = [
        r'üåê Public URL: (https://[^\s]+)',
        r'Public URL: (https://[^\s]+)',
        r'üîó Please visit (https://[^\s]+)',
        r'Please visit (https://[^\s]+)',
        r'Session string generated! You can now login to Hikka using this link: (https://[^\s]+)',
        r'(https://[a-zA-Z0-9.\-]+hik[a-zA-Z0-9.\-/=\?#&%_]+)',
        r'(https://[^\s]+\.lhr\.life)',
        r'(https://[^\s]+\.loca\.lt)'
    ]
    return await _find_login_url_from_logs(ub_username, server_ip, patterns)

async def find_login_url_in_loop(ub_username: str, server_ip: str, ub_type: str):
    end_time = asyncio.get_event_loop().time() + 120
    while asyncio.get_event_loop().time() < end_time:
        url = await find_login_url_from_journal(ub_username, server_ip)
        if url:
            return url
        await asyncio.sleep(5)
    return None

async def check_journal_for_restart(ub_username: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n 50 --output cat"
    res = await run_command_async(cmd, server_ip, timeout=20, check_output=False)
    return res["success"] and res["output"] and re.search(r'restarting', res["output"], re.IGNORECASE)

async def ensure_system_utils(server_ip: str):
    await run_command_async("sudo apt-get update -qq", server_ip, capture_output=False)
    await run_command_async("sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq git ca-certificates procps python3-pip", server_ip, capture_output=False)

async def set_home_directory_permissions(ub_username: str, server_ip: str):
    home_dir = f"/home/{shlex.quote(ub_username)}"
    command = f"sudo chmod 750 {home_dir}"
    logger_lm.info(f"Setting permissions for user directory: {command} on {server_ip}")
    result = await run_command_async(command, server_ip)
    if not result.get("success"):
        logger_lm.error(f"Failed to set permissions for {home_dir} on {server_ip}: {result.get('error')}")
    return result

async def cleanup_user_home_if_needed(ub_username: str, server_ip: str):
    home_dir = f"/home/{ub_username}"
    df_cmd = f"df --output=avail {home_dir} | tail -1 | awk '{{print int($1/1024)}}'"
    res = await run_command_async(df_cmd, server_ip)
    try:
        free_mb = int(res.get("output", "0"))
    except Exception:
        free_mb = 0
    if free_mb < 300:
        cleanup_cmd = f'''
USER_HOME="{home_dir}";
MIN_FREE_MB=300;
get_free_mb() {{
  df --output=avail "$USER_HOME" | tail -1 | awk '{{print int($1/1024)}}';
}}
free_mb=$(get_free_mb);
while [ "$free_mb" -lt "$MIN_FREE_MB" ]; do
  big_files=$(find "$USER_HOME" -type f -size +199M);
  if [ -n "$big_files" ]; then
    echo "$big_files" | xargs -d '\n' rm -f;
    free_mb=$(get_free_mb);
    continue;
  fi;
  largest=$(find "$USER_HOME" -type f -size +19M -printf "%s %p\\n" | sort -nr | head -1 | awk '{{print $2}}');
  if [ -n "$largest" ]; then
    rm -f "$largest";
    free_mb=$(get_free_mb);
    continue;
  fi;
  newest=$(find "$USER_HOME" -type f -size -20M -printf "%T@ %p\\n" | sort -nr | head -1 | awk '{{print $2}}');
  if [ -n "$newest" ]; then
    rm -f "$newest";
    free_mb=$(get_free_mb);
    continue;
  fi;
  break;
done
'''
        await run_command_async(f"bash -c {shlex.quote(cleanup_cmd)}", server_ip)

async def create_server_user_and_setup_hikka(tg_user_id: int, username_base: str, ub_type: str, server_ip: str, bot=None, chat_id=None):
    ub_username = f"ub{username_base}"
    if await user_exists(ub_username, server_ip) or await db.get_userbot_data(ub_username=ub_username):
        await delete_userbot_full(ub_username, server_ip)
        await asyncio.sleep(1)
    
    await ensure_system_utils(server_ip)
    
    version_cmd = "cat /etc/os-release | grep ^VERSION_ID= | cut -d'\"' -f2"
    version_res = await run_command_async(version_cmd, server_ip)
    ubuntu_version = (version_res.get("output") or "").strip()
    
    python_path_res = await run_command_async("which python3", server_ip)
    if not python_path_res["success"] or not python_path_res["output"]:
        return {"success": False, "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ python3 –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ."}
    python_executable = python_path_res["output"].strip()
    
    if not (await run_command_async(f'sudo adduser --disabled-password --gecos "" {shlex.quote(ub_username)}', server_ip))["success"]:
        return {"success": False, "message": "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."}

    image_dir = "/var/lib/ubimages"
    image_file = f"{image_dir}/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    create_img_cmds = [
        f"sudo mkdir -p {image_dir}",
        f"sudo fallocate -l 812M {image_file}",
        f"sudo mkfs.ext4 -F {image_file}",
        f"sudo mount -o loop {image_file} {home_dir}",
        f"sudo chown {ub_username}:{ub_username} {home_dir}"
    ]
    for cmd in create_img_cmds:
        res = await run_command_async(cmd, server_ip)
        if not res["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ loop-–æ–±—Ä–∞–∑–∞: {cmd}"}

    await cleanup_user_home_if_needed(ub_username, server_ip)

    perm_res = await set_home_directory_permissions(ub_username, server_ip)
    if not perm_res.get("success"):
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."}

    repo_map = {
        "hikka": {"dir": "Hikka", "module": "hikka"},
        "heroku": {"dir": "Heroku", "module": "heroku"},
        "fox": {"dir": "FoxUserbot", "exec_command": "python3 main.py"}
    }
    
    r_info = repo_map.get(ub_type)
    if not r_info: return {"success": False, "message": f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —é–∑–µ—Ä–±–æ—Ç–∞: {ub_type}"}

    home_dir = f"/home/{ub_username}"
    ub_path = os.path.join(home_dir, r_info['dir'])

    auth_config = server_config.get_server_auth_config(server_ip)
    webui_port = None

    if auth_config.get('mode') == 'port' and ub_type in ['hikka', 'heroku']:
        webui_port = random.randint(20000, 65535)
        logger_lm.info(f"–î–ª—è {ub_username} –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ {server_ip} —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –ø–æ—Ä—Ç {webui_port} –¥–ª—è WebUI.")

    if not await db.add_userbot_record(tg_user_id, ub_username, ub_type, ub_path, server_ip, webui_port):
        await run_command_async(f'sudo deluser --remove-home {shlex.quote(ub_username)}', server_ip)
        return {"success": False, "message": "–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –≤ –ë–î."}

    source_code_path = f"/root/{r_info['dir']}"
    copy_cmd = f"sudo cp -r {source_code_path} {home_dir}/"
    if not (await run_command_async(copy_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞."}
        
    chown_cmd = f"sudo chown -R {ub_username}:{ub_username} {ub_path}"
    if not (await run_command_async(chown_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∞–≤ –Ω–∞ —Ñ–∞–π–ª—ã —é–∑–µ—Ä–±–æ—Ç–∞."}

    if ubuntu_version == "24.04":
        venv_path = os.path.join(home_dir, "venv")
        venv_cmd = f"sudo -u {ub_username} python3 -m venv {shlex.quote(venv_path)}"
        res_venv = await run_command_async(venv_cmd, server_ip)
        if not res_venv["success"]:
            diag_msgs = []
            venv_pkg_check = await run_command_async("dpkg -l | grep python3-venv", server_ip)
            diag_msgs.append(f"python3-venv: {venv_pkg_check.get('output','(none)')}")
            py_check = await run_command_async("which python3", server_ip)
            diag_msgs.append(f"which python3: {py_check.get('output','(none)')}")
            perm_check = await run_command_async(f"ls -ld {home_dir}", server_ip)
            diag_msgs.append(f"ls -ld {home_dir}: {perm_check.get('output','(none)')}")
            space_check = await run_command_async(f"df -h {home_dir}", server_ip)
            diag_msgs.append(f"df -h {home_dir}: {space_check.get('output','(none)')}")
            diag_msgs.append(f"venv stdout: {res_venv.get('output','')}")
            diag_msgs.append(f"venv stderr: {res_venv.get('error','')}")
            logging.error("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è venv. –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞:\n" + "\n".join(diag_msgs))
            if bot and chat_id:
                await bot.send_message(chat_id, "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è venv. –ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏:\n" + "\n".join(diag_msgs))
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è venv. –°–º. –ª–æ–≥–∏ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏."}
        req_path = os.path.join(ub_path, "requirements.txt")
        pip_install_cmd = f"sudo -u {ub_username} {venv_path}/bin/pip install --upgrade pip && sudo -u {ub_username} {venv_path}/bin/pip install -r {shlex.quote(req_path)}"
        res_pip = await run_command_async(pip_install_cmd, server_ip, check_output=False, timeout=600)
        if res_pip["exit_status"] != 0:
            logging.warning(f"–ö–æ–º–∞–Ω–¥–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è {ub_username} –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π. –ö–æ–¥ –≤–æ–∑–≤—Ä–∞—Ç–∞: {res_pip['exit_status']}; STDERR: {res_pip.get('error', '')}; STDOUT: {res_pip.get('output', '')}")
        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", f"{venv_path}/bin/python")
        else:
            exec_start_cmd = f"{venv_path}/bin/python -m {r_info['module']}"
    else:
        local_wheels_path = f"/opt/pip_wheels/{ub_type}/"
        install_deps_cmd = (
            f"cd '{ub_path}' && [ -f requirements.txt ] && "
            f"{python_executable} -m pip install --user -q --find-links=file://{local_wheels_path} -r requirements.txt"
        )
        install_res = await run_command_async(install_deps_cmd, server_ip, user=ub_username, check_output=False, timeout=600)
        if install_res["exit_status"] != 0:
            logging.warning(f"–ö–æ–º–∞–Ω–¥–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è {ub_username} –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –∫–æ–¥–æ–º {install_res['exit_status']}. –û—à–∏–±–∫–∞: {install_res['error']}")
        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", python_executable)
        else:
            exec_start_cmd = f"{python_executable} -m {r_info['module']}"

    if webui_port:
        exec_start_cmd += f" --port {webui_port}"

    s_name = f"hikka-{ub_username}.service"
    s_content = f"""[Unit]
Description={ub_type.capitalize()} UB for {ub_username}
After=network.target
[Service]
User={ub_username}
Group={ub_username}
WorkingDirectory={ub_path}
ExecStart={exec_start_cmd}
Restart=always
RestartSec=10
Environment=\"PATH=/home/{ub_username}/.local/bin:/usr/bin:/bin:/usr/local/bin\"
StandardOutput=journal
StandardError=journal
MemoryHigh=500M
MemoryMax=512M
MemorySwapMax=0
CPUQuota=60%
[Install]
WantedBy=multi-user.target
"""
    await run_command_async(f"echo '{s_content}' | sudo tee /etc/systemd/system/{s_name} > /dev/null", server_ip)
    await run_command_async(f"sudo chmod 644 /etc/systemd/system/{s_name}", server_ip)

    for cmd in ["sudo systemctl daemon-reload", f"sudo systemctl enable {s_name}", f"sudo systemctl start {s_name}"]:
        res_cmd = await run_command_async(cmd, server_ip)
        if not res_cmd["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"–û—à–∏–±–∫–∞ systemd: {cmd}."}
            
    await db.update_userbot_status(ub_username, "running")

    tmp_images_dir = "/var/lib/user-tmp"
    await run_command_async(f"sudo mkdir -p {tmp_images_dir}", server_ip)
    
    tmp_image_file = f"{tmp_images_dir}/{ub_username}-tmp.img"
    create_tmp_image_cmd = f"sudo fallocate -l 120M {tmp_image_file} && sudo mkfs.ext4 -F {tmp_image_file}"
    await run_command_async(create_tmp_image_cmd, server_ip)
    
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    create_mount_point_cmd = f"sudo mkdir -p {isolated_tmp_dir} && sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(create_mount_point_cmd, server_ip)
    
    fix_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_permissions_cmd, server_ip)
    
    setup_isolated_dir_cmd = "sudo mkdir -p /var/lib/user-tmp && sudo chown root:root /var/lib/user-tmp && sudo chmod 755 /var/lib/user-tmp && sudo setfacl -b /var/lib/user-tmp"
    await run_command_async(setup_isolated_dir_cmd, server_ip)
    
    fix_existing_isolated_cmd = "sudo chmod 755 /var/lib/user-tmp 2>/dev/null || true && sudo chown root:root /var/lib/user-tmp 2>/dev/null || true && sudo setfacl -b /var/lib/user-tmp 2>/dev/null || true"
    await run_command_async(fix_existing_isolated_cmd, server_ip)
    
    fix_all_isolated_cmd = "sudo find /var/lib/user-tmp -type d -exec chmod 755 {} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -type d -exec chown root:root {} \\; 2>/dev/null || true"
    await run_command_async(fix_all_isolated_cmd, server_ip)
    
    fix_user_dirs_cmd = f"sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec bash -c 'user=${{1#/var/lib/user-tmp/}}; chown $user:$user $1' _ {{}} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec chmod 700 {{}} \\; 2>/dev/null || true"
    await run_command_async(fix_user_dirs_cmd, server_ip)
    
    fix_mount_point_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_point_cmd, server_ip)
    
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    add_fstab_cmd = f"echo '{fstab_entry}' | sudo tee -a /etc/fstab"
    await run_command_async(add_fstab_cmd, server_ip)
    
    mount_cmd = f"sudo mount {isolated_tmp_dir}"
    await run_command_async(mount_cmd, server_ip)
    
    fix_mount_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_permissions_cmd, server_ip)
    
    quota_cmd = f"sudo quotacheck -cum {isolated_tmp_dir} && sudo quotaon {isolated_tmp_dir} && sudo setquota -u {ub_username} 0 122880 0 0 {isolated_tmp_dir}"
    quota_result = await run_command_async(quota_cmd, server_ip, check_output=False)
    
    if not quota_result.get("success"):
        logging.warning(f"Quota setup failed on {server_ip}: {quota_result.get('error', 'Unknown error')}")
        logging.info(f"Using filesystem size limit instead of quotas for {ub_username}")
    
    remove_old_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_old_pam_cmd, server_ip)

    pam_entries = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries:
        add_pam_cmd = f"echo '{pam_entry}' | sudo tee -a /etc/security/pam_env.conf"
        await run_command_async(add_pam_cmd, server_ip)
    
    check_pam_env_cmd = "grep -q 'pam_env' /etc/pam.d/common-session || echo 'session required pam_env.so' | sudo tee -a /etc/pam.d/common-session"
    await run_command_async(check_pam_env_cmd, server_ip)
    
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    env_vars = f"""
# --- UB: TMP environment variables ---
export TMPDIR={isolated_tmp_dir}
export TMP={isolated_tmp_dir}
export TEMP={isolated_tmp_dir}
# --- END UB ---
"""
    
    for profile in shell_profiles:
        add_env_cmd = f"echo '{env_vars}' | sudo tee -a {profile}"
        await run_command_async(add_env_cmd, server_ip)
    
    source_profile_cmd = f"sudo -u {ub_username} bash -c 'source ~/.bashrc && echo \"TMPDIR set to: $TMPDIR\"'"
    await run_command_async(source_profile_cmd, server_ip, check_output=False)
    
    block_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /tmp"
    await run_command_async(block_tmp_cmd, server_ip)

    block_var_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /var/tmp"
    await run_command_async(block_var_tmp_cmd, server_ip)

    return {"success": True, "ub_username": ub_username, "webui_port": webui_port}

async def is_service_active(service_name: str, server_ip: str):
    res = await run_command_async(f"sudo systemctl is-active {service_name}", server_ip, check_output=False)
    return res["success"] and res["output"] == "active"



async def delete_userbot_full(ub_username: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    
    # 1. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ –æ—Ç–∫–ª—é—á–∞–µ–º systemd —Å–µ—Ä–≤–∏—Å
    await asyncio.gather(
        run_command_async(f"sudo systemctl stop {s_name}", server_ip, check_output=False),
        run_command_async(f"sudo systemctl disable {s_name}", server_ip, check_output=False)
    )
    
    # 2. –£–±–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if await user_exists(ub_username, server_ip):
        await run_command_async(f'sudo pkill -u {ub_username}', server_ip, check_output=False)
        await asyncio.sleep(1)
        await run_command_async(f'sudo pkill -9 -u {ub_username}', server_ip, check_output=False)
        await asyncio.sleep(1)
    
    # 3. –£–¥–∞–ª—è–µ–º systemd —Ñ–∞–π–ª –∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º daemon
    await asyncio.gather(
        run_command_async(f"sudo rm -f /etc/systemd/system/{s_name}", server_ip, check_output=False),
        run_command_async("sudo systemctl daemon-reload", server_ip, check_output=False),
        clear_journal_logs_for_service(s_name, server_ip)
    )

    # 4. –†–∞–∑–º–æ–Ω—Ç–∏—Ä—É–µ–º –∏ —É–¥–∞–ª—è–µ–º loop-–æ–±—Ä–∞–∑ (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
    image_file = f"/var/lib/ubimages/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    await run_command_async(f"sudo umount {home_dir}", server_ip, check_output=False)
    await run_command_async(f"sudo rm -f {image_file}", server_ip, check_output=False)

    # 5. –û—á–∏—â–∞–µ–º –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π tmp –∏ ACL –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    tmp_image_file = f"/var/lib/user-tmp/{ub_username}-tmp.img"
    
    # 5.1. –†–∞–∑–º–æ–Ω—Ç–∏—Ä—É–µ–º –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π tmp
    await run_command_async(f"sudo umount {isolated_tmp_dir}", server_ip, check_output=False)
    
    # 5.2. –£–¥–∞–ª—è–µ–º ACL –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ /tmp
    remove_acl_cmd = f"sudo setfacl -x u:{ub_username} /tmp 2>/dev/null || true && sudo setfacl -x d:u:{ub_username} /tmp 2>/dev/null || true"
    await run_command_async(remove_acl_cmd, server_ip, check_output=False)
    
    # 5.3. –£–¥–∞–ª—è–µ–º ACL –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ /var/tmp
    remove_var_tmp_acl_cmd = f"sudo setfacl -x u:{ub_username} /var/tmp 2>/dev/null || true"
    await run_command_async(remove_var_tmp_acl_cmd, server_ip, check_output=False)
    
    # 5.4. –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ /etc/fstab
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    remove_fstab_cmd = f"sudo sed -i 's|{fstab_entry}|' /etc/fstab"
    await run_command_async(remove_fstab_cmd, server_ip, check_output=False)
    
    # 5.5. –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å–∏ –∏–∑ PAM
    pam_entries_to_remove = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries_to_remove:
        remove_pam_cmd = f"sudo sed -i '/{pam_entry}/d' /etc/security/pam_env.conf"
        await run_command_async(remove_pam_cmd, server_ip, check_output=False)
    
    # 5.6. –£–¥–∞–ª—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞ —Å–ª—É—á–∞–π –¥—É–±–ª–∏–∫–∞—Ç–æ–≤)
    remove_all_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_all_pam_cmd, server_ip, check_output=False)
    
    # 5.7. –£–¥–∞–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ shell-–ø—Ä–æ—Ñ–∏–ª–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    for profile in shell_profiles:
        remove_env_cmd = f"sudo sed -i '/# --- UB: TMP environment variables ---/,/# --- END UB ---/d' {profile}"
        await run_command_async(remove_env_cmd, server_ip, check_output=False)

    # 5.8. –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ tmp
    cleanup_cmds = [
        f"sudo rm -rf {isolated_tmp_dir}",
        f"sudo rm -f {tmp_image_file}",
        f"sudo rmdir /var/lib/user-tmp 2>/dev/null || true"  # —É–¥–∞–ª—è–µ–º /var/lib/user-tmp –µ—Å–ª–∏ –ø—É—Å—Ç–æ–π
    ]
    for cmd in cleanup_cmds:
        await run_command_async(cmd, server_ip, check_output=False)

    # 6. –£–¥–∞–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –µ–≥–æ –¥–æ–º–∞—à–Ω—é—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    if await user_exists(ub_username, server_ip):
        await run_command_async(f'sudo deluser --remove-home {ub_username}', server_ip, check_output=False)
        
    # 7. –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    await db.delete_userbot_record(ub_username)
    return {"success": True, "message": f"UB {ub_username} –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω."}

async def manage_ub_service(ub_username: str, action: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    if action not in ["start", "stop", "restart"]:
        return {"success": False, "message": "–ù–µ–≤–µ—Ä–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ."}
    # --- –û—á–∏—Å—Ç–∫–∞ –¥–æ–º–∞—à–Ω–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–∏ –Ω–µ—Ö–≤–∞—Ç–∫–µ –º–µ—Å—Ç–∞ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º/—Ä–µ—Å—Ç–∞—Ä—Ç–æ–º ---
    if action in ["start", "restart"]:
        await cleanup_user_home_if_needed(ub_username, server_ip)
    res = await run_command_async(f"sudo systemctl {action} {s_name}", server_ip)
    if not res["success"]:
        await db.update_userbot_status(ub_username, "error")
        return {"success": False, "message": f"–û—à–∏–±–∫–∞ {action}"}
    
    is_active_after = await is_service_active(s_name, server_ip)
    new_stat = "running" if is_active_after and action != "stop" else "stopped"
    
    if action == "stop" and new_stat == "stopped":
        await db.update_userbot_status_with_time(ub_username, new_stat, datetime.datetime.now())
    elif action == "start" and new_stat == "running":
        await db.update_userbot_started_time(ub_username, datetime.datetime.now())
    else:
        await db.update_userbot_status(ub_username, new_stat)
    
    return {"success": True}

async def check_for_session_file(ub_username: str, server_ip: str) -> bool:
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or not await user_exists(ub_username, server_ip): return False
    ub_type, hikka_path = ub_data.get("ub_type"), ub_data.get("hikka_path")
    if not ub_type or not hikka_path: return False
    
    cmd = f'sudo find {shlex.quote(hikka_path)} -maxdepth 1 \\( -name "*.session" -o -name "heroku*" \\) -print -quit'
    res = await run_command_async(cmd, server_ip, check_output=False)
    return bool(res["success"] and res["output"])
    
async def get_all_userbots_cpu_usage(server_ip: str):
    cmd = "ps -eo user:20,pcpu,comm --no-headers | grep '^ub'"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)

    if not res["success"] or not res["output"]:
        logging.warning(f"Could not get CPU usage from {server_ip} using 'ps'.")
        return {}
    
    cpu_usage_map = {}
    lines = res["output"].strip().split('\n')

    for line in lines:
        parts = line.strip().split()
        if len(parts) >= 2:
            try:
                username = parts[0]
                cpu_percent = float(parts[1])
                cpu_usage_map[username] = cpu_usage_map.get(username, 0) + cpu_percent
            except (ValueError, IndexError):
                continue
    return cpu_usage_map
    
async def clear_journal_logs_for_service(service_name: str, server_ip: str):
    logger_lm.info(f"–û—á–∏—Å—Ç–∫–∞ –ª–æ–≥–æ–≤ –¥–ª—è —Å–ª—É–∂–±—ã {service_name} –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ {server_ip}...")
    cmd = f"sudo journalctl --rotate && sudo journalctl -u {shlex.quote(service_name)} --vacuum-time=1s"
    await run_command_async(cmd, server_ip, check_output=False)
    logger_lm.info(f"–õ–æ–≥–∏ –¥–ª—è {service_name} –æ—á–∏—â–µ–Ω—ã.")
    
async def get_batch_service_statuses(service_names: list[str], server_ip: str) -> dict[str, bool]:
    if not service_names:
        return {}
    
    command = "systemctl list-units --full --all --plain --no-legend " + " ".join(shlex.quote(s) for s in service_names)
    res = await run_command_async(command, server_ip, check_output=False, timeout=45)
    
    statuses = {name: False for name in service_names}
    
    if res["success"] and res["output"]:
        for line in res["output"].strip().split('\n'):
            parts = line.split()
            if len(parts) >= 4:
                service_name = parts[0]
                active_state = parts[2]
                if service_name in statuses and active_state == 'active':
                    statuses[service_name] = True
    return statuses



def _load_heroku_db(project_path: Path, tg_id: str) -> dict:
    db_path = project_path / f"config-{tg_id}.json"
    if not db_path.exists():
        # –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
        import logging, os
        files = [f.name for f in project_path.glob('config-*.json')]
        try:
            dir_stat = os.stat(project_path)
            file_stat = os.stat(db_path) if db_path.exists() else None
        except Exception as e:
            dir_stat = str(e)
            file_stat = None
        debug_msg = f"[DEBUG] _load_heroku_db: project_path={project_path}, tg_id={tg_id}, db_path={db_path}, files={files}, dir_stat={dir_stat}, file_stat={file_stat}"
        logging.error(debug_msg)
        print(debug_msg)
        raise FileNotFoundError(f"–ù–µ –Ω–∞–π–¥–µ–Ω —Ñ–∞–π–ª config-<tg_id>.json –≤ {project_path}")
    with open(db_path, "r", encoding="utf-8") as f:
        db = json.load(f)
    return db

def _backup_db(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    db = _load_heroku_db(project_path, tg_id)
    fname = f"db-backup-{datetime.datetime.now():%d-%m-%Y-%H-%M}.json"
    out_path = out_dir / fname
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(db, f, ensure_ascii=True, indent=None, separators=(", ", ": "))
    return out_path

def _backup_mods(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    loaded_modules_dir = project_path / "loaded_modules"
    mods_zip_path = out_dir / f"mods-{datetime.datetime.now():%d-%m-%Y-%H-%M}.zip"
    db = _load_heroku_db(project_path, tg_id)
    db_mods = db.get("LoaderMod", {}).get("loaded_modules", {})
    with zipfile.ZipFile(mods_zip_path, "w", zipfile.ZIP_DEFLATED) as mods_zip:
        found = False
        for file in loaded_modules_dir.glob(f"*{tg_id}.py"):
            mods_zip.write(file, file.name)
            found = True
        mods_zip.writestr("db_mods.json", json.dumps(db_mods, ensure_ascii=True, indent=None, separators=(", ", ": ")))
    return mods_zip_path

def _backup_all(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    db = _load_heroku_db(project_path, tg_id)
    db_bytes = json.dumps(db, ensure_ascii=True, indent=None, separators=(", ", ": ")).encode()
    loaded_modules_dir = project_path / "loaded_modules"
    mods_zip_path = out_dir / "mods.zip"
    db_mods = db.get("LoaderMod", {}).get("loaded_modules", {})
    with zipfile.ZipFile(mods_zip_path, "w", zipfile.ZIP_DEFLATED) as mods_zip:
        found = False
        for file in loaded_modules_dir.glob(f"*{tg_id}.py"):
            mods_zip.write(file, file.name)
            found = True
        mods_zip.writestr("db_mods.json", json.dumps(db_mods, ensure_ascii=True, indent=None, separators=(", ", ": ")))
    backup_zip_path = out_dir / f"backup-all-{datetime.datetime.now():%d-%m-%Y-%H-%M}.zip"
    with zipfile.ZipFile(backup_zip_path, "w", zipfile.ZIP_DEFLATED) as backup_zip:
        backup_zip.writestr("db.json", db_bytes)
        with open(mods_zip_path, "rb") as mods_file:
            backup_zip.writestr("mods.zip", mods_file.read())
    os.remove(mods_zip_path)
    return backup_zip_path

async def make_heroku_backup(ub_username: str, server_ip: str, backup_type: str = "all") -> tuple[str, str]:
    """
    –°–æ–∑–¥–∞—ë—Ç —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é Heroku-—é–∑–µ—Ä–±–æ—Ç–∞ (db, mods, all) –≤–æ –≤—Ä–µ–º–µ–Ω–Ω–æ–π —É–Ω–∏–∫–∞–ª—å–Ω–æ–π –ø–∞–ø–∫–µ –≤ /tmp.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (–ø—É—Ç—å –∫ —Ñ–∞–π–ª—É, –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è).
    –ü–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª –∏ –ø–∞–ø–∫–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–¥–∞–ª–µ–Ω—ã.
    """
    import asyncio
    import aiofiles
    import logging
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —é–∑–µ—Ä–±–æ—Ç–µ
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or ub_data.get("ub_type") != "heroku":
        raise ValueError("–ë—ç–∫–∞–ø –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è Heroku-—é–∑–µ—Ä–±–æ—Ç–æ–≤.")
    hikka_path = ub_data.get("hikka_path")
    if not hikka_path:
        raise ValueError("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è Heroku-—é–∑–µ—Ä–±–æ—Ç–∞.")
    tg_id = None
    project_path = Path(hikka_path)
    # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    try:
        files_in_dir = list(project_path.glob("config-*.json"))
        logging.info(f"[make_heroku_backup] –ü–æ–∏—Å–∫ config-<tg_id>.json –≤ {hikka_path}. –ù–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: {[f.name for f in files_in_dir]}")
    except Exception as e:
        logging.error(f"[make_heroku_backup] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ {hikka_path}: {e}")
        files_in_dir = []
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º tg_id –ø–æ —Ñ–∞–π–ª—É config-<tg_id>.json
    for file in files_in_dir:
        name = file.name
        if name.startswith("config-") and name.endswith(".json"):
            try:
                tg_id_candidate = name[7:-5]
                if tg_id_candidate.isdigit():
                    tg_id = tg_id_candidate
                    break
                else:
                    logging.warning(f"[make_heroku_backup] –§–∞–π–ª {name} –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —á–∏—Å–ª–æ–≤–æ–π tg_id")
            except Exception as e:
                logging.error(f"[make_heroku_backup] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ {name}: {e}")
    if not tg_id:
        # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —á–µ—Ä–µ–∑ SSH
        ls_cmd = f"ls -l {hikka_path}"
        stat_cmd = f"stat {hikka_path} || true"
        ls_res = await run_command_async(ls_cmd, server_ip, check_output=False)
        stat_res = await run_command_async(stat_cmd, server_ip, check_output=False)
        diag = f"\n[DIAG] ls -l: {ls_res.get('output','')}\n[DIAG] stat: {stat_res.get('output','')}"
        raise FileNotFoundError(f"[make_heroku_backup] –ù–µ –Ω–∞–π–¥–µ–Ω —Ñ–∞–π–ª config-<tg_id>.json –≤ {hikka_path}. –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {[f.name for f in files_in_dir]}{diag}")
    # –°–æ–∑–¥–∞—ë–º —É–Ω–∏–∫–∞–ª—å–Ω—É—é –≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–∞–ø–∫—É
    unique = uuid.uuid4().hex[:8]
    tmp_dir = Path("/tmp") / f"heroku_backup_{tg_id}_{unique}"
    tmp_dir.mkdir(parents=True, exist_ok=True)
    # –î–µ–ª–∞–µ–º –±—ç–∫–∞–ø
    if backup_type == "db":
        backup_path = _backup_db(project_path, tg_id, tmp_dir)
    elif backup_type == "mods":
        backup_path = _backup_mods(project_path, tg_id, tmp_dir)
    elif backup_type == "all":
        backup_path = _backup_all(project_path, tg_id, tmp_dir)
    else:
        raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–∏–ø –±—ç–∫–∞–ø–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'db', 'mods' –∏–ª–∏ 'all'.")
    return str(backup_path), backup_path.name

def cleanup_heroku_backup_file(backup_file_path: str):
    """
    –£–¥–∞–ª—è–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–∞–ø–∫—É, –≤ –∫–æ—Ç–æ—Ä–æ–π –ª–µ–∂–∏—Ç backup_file_path.
    """
    path = Path(backup_file_path)
    tmp_dir = path.parent
    if tmp_dir.exists() and str(tmp_dir).startswith("/tmp/heroku_backup_"):
        shutil.rmtree(tmp_dir, ignore_errors=True)

def generate_strong_password(length=28):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{};:,./<>?"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

async def secure_and_prepare_server(ip, old_ssh_user, old_ssh_pass):
    import asyncssh
    import shlex
    import logging

    new_password = generate_strong_password(28)
    pubkey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIF8o56JaCLaEta/fNV9I235ngQLcjqmOutIiGkYpdSc8 qqsharki4@gmail.com"
    sshd_config = '''Port 22
AddressFamily any
ListenAddress 0.0.0.0
Protocol 2
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
LoginGraceTime 60
PermitRootLogin yes
StrictModes yes
MaxAuthTries 3
MaxSessions 5
PubkeyAuthentication yes
PasswordAuthentication yes
PermitRootLogin yes
PermitEmptyPasswords no
KbdInteractiveAuthentication no
UsePAM yes
X11Forwarding no
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
ClientAliveInterval 300
ClientAliveCountMax 2
Compression no
Subsystem sftp /usr/lib/openssh/sftp-server
AllowAgentForwarding no
AllowTcpForwarding yes
GatewayPorts no
PermitTunnel no'''

    try:
        async with asyncssh.connect(ip, username=old_ssh_user, password=old_ssh_pass, known_hosts=None) as conn:
            # 1. –£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–ª—é—á–µ–π –∏–∑ /root/.ssh –∏ /home/*/.ssh
            try:
                res = await conn.run('rm -rf /root/.ssh/*', check=False)
                logging.info(f"rm root keys: {res.stdout} {res.stderr}")
                res = await conn.run('for d in /home/*/.ssh; do rm -rf "$d"/*; done', check=False)
                logging.info(f"rm home keys: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ ssh-–∫–ª—é—á–µ–π: {e}")
                raise

            # 2. –ó–∞–ø—Ä–µ—Ç SSH –¥–ª—è –≤—Å–µ—Ö –∫—Ä–æ–º–µ root
            try:
                res = await conn.run('for u in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do sudo usermod -s /usr/sbin/nologin $u; done', check=False)
                logging.info(f"usermod: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ usermod: {e}")
                raise

            # 3. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞
            try:
                res = await conn.run('mkdir -p /root/.ssh && chmod 700 /root/.ssh', check=True)
                logging.info(f"mkdir .ssh: {res.stdout} {res.stderr}")
                res = await conn.run(f'echo "{pubkey}" > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys', check=True)
                logging.info(f"add pubkey: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞: {e}")
                raise

            # 4. –ó–∞–ø–∏—Å—å sshd_config
            try:
                res = await conn.run(f'echo {shlex.quote(sshd_config)} | sudo tee /etc/ssh/sshd_config', check=True)
                logging.info(f"sshd_config: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ sshd_config: {e}")
                raise

            # 5. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —Ä–µ—Å—Ç–∞—Ä—Ç sshd
            try:
                res = await conn.run('sudo sshd -t', check=True)
                logging.info(f"sshd -t: {res.stdout} {res.stderr}")

                # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ ssh-—Å–µ—Ä–≤–∏—Å–æ–≤
                res_units = await conn.run('systemctl list-units --type=service | grep ssh', check=False)
                units = res_units.stdout or ''
                print(f"systemctl list-units --type=service | grep ssh: {units}")
                if 'ssh.service' in units:
                    ssh_service = 'ssh'
                elif 'sshd.service' in units:
                    ssh_service = 'sshd'
                else:
                    ssh_service = 'ssh'  # fallback
                print(f"–í—ã–±—Ä–∞–Ω —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: {ssh_service}")

                res = await conn.run(f'sudo systemctl restart {ssh_service}', check=True)
                logging.info(f"restart {ssh_service}: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ ssh-—Å–µ—Ä–≤–∏—Å–∞: {e}")
                raise

            # 6. –°–º–µ–Ω–∞ –ø–∞—Ä–æ–ª—è root (–ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Ä–µ—Å—Ç–∞—Ä—Ç–∞ sshd)
            try:
                res = await conn.run('sudo chpasswd', input=f'root:{new_password}\n', check=True)
                logging.info(f"chpasswd: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ –ø–∞—Ä–æ–ª—è root: {e}")
                raise
    except Exception as e:
        logging.error(f"[secure_and_prepare_server] –û—à–∏–±–∫–∞: {repr(e)}")
        raise
    return new_password

async def add_server_with_security(ip: str, user: str, password: str, details: dict) -> str | None:
    try:
        new_password = await secure_and_prepare_server(ip, user, password)
    except Exception as e:
        print(f"[add_server_with_security] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ —Å–µ—Ä–≤–µ—Ä–∞: {e}")
        return None

    servers = server_config.get_servers()
    servers[ip] = {
        "ssh_user": user,
        "ssh_pass": new_password,
        "name": details.get("name", "serv_new"),
        "country": details.get("country", "Unknown"),
        "city": details.get("city", "Unknown"),
        "regionName": details.get("regionName", "N/A"),
        "flag": details.get("flag", "üè≥Ô∏è"),
        "code": details.get("code", ip.split('.')[-1]),
        "org": details.get("org", "N/A"),
        "timezone": details.get("timezone", "N/A"),
        "hosting": details.get("hosting", False),
        "proxy": details.get("proxy", False),
        "vpn": details.get("vpn", False),
        "status": "test",
        "slots": 0
    }
    if server_config._save_servers(servers):
        return new_password
    else:
        return None
        
async def check_systemd_file_exists(service_name: str, server_ip: str) -> bool:
    command = f"test -f /etc/systemd/system/{shlex.quote(service_name)}"
    result = await run_command_async(command, server_ip, check_output=False)
    return result.get("exit_status") == 0



async def make_heroku_backup_ssh(ub_username: str, server_ip: str, backup_type: str = "all") -> tuple[str, str]:
    """
    –°–æ–∑–¥–∞—ë—Ç –±—ç–∫–∞–ø Heroku-—é–∑–µ—Ä–±–æ—Ç–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ SSH –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ, —Å–∫–∞—á–∏–≤–∞–µ—Ç –∞—Ä—Ö–∏–≤ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –∏ —É–¥–∞–ª—è–µ—Ç –µ–≥–æ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (–ø—É—Ç—å –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É –∞—Ä—Ö–∏–≤—É, –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è).
    """
    import aiofiles
    import shutil
    import random
    import string
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —é–∑–µ—Ä–±–æ—Ç–µ
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or ub_data.get("ub_type") != "heroku":
        raise ValueError("–ë—ç–∫–∞–ø –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è Heroku-—é–∑–µ—Ä–±–æ—Ç–æ–≤.")
    hikka_path = ub_data.get("hikka_path")
    if not hikka_path:
        raise ValueError("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è Heroku-—é–∑–µ—Ä–±–æ—Ç–∞.")
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π tmp-–ø—É—Ç—å –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ
    rand = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    remote_tmp = f"/tmp/heroku_backup_{ub_username}_{rand}"
    # 1. –ù–∞—Ö–æ–¥–∏–º tg_id –∏ –¥–µ–ª–∞–µ–º –∞—Ä—Ö–∏–≤ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ
    backup_type_map = {
        "all": "all",
        "db": "db",
        "mods": "mods"
    }
    if backup_type not in backup_type_map:
        raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–∏–ø –±—ç–∫–∞–ø–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 'db', 'mods' –∏–ª–∏ 'all'.")
    # –ö–æ–º–∞–Ω–¥–∞: –Ω–∞–π—Ç–∏ tg_id, —Å–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É, —Å–¥–µ–ª–∞—Ç—å –±—ç–∫–∞–ø —á–µ—Ä–µ–∑ python
    remote_script = f'''
set -e
cd {shlex.quote(hikka_path)}
tg_id=$(ls config-*.json | sed -nE 's/config-([0-9]+)\\.json/\\1/p' | head -n1)
if [ -z "$tg_id" ]; then echo "NO_TGID"; exit 1; fi
mkdir -p {remote_tmp}
# –°–æ–∑–¥–∞—ë–º db-backup
python3 -c "import json,datetime; db=json.load(open('config-$tg_id.json')); open('{remote_tmp}/db-backup-'+datetime.datetime.now().strftime('%d-%m-%Y-%H-%M')+'.json','w').write(json.dumps(db,ensure_ascii=True,separators=(',',':')));" >/dev/null 2>&1
if [ '{backup_type}' = 'mods' ] || [ '{backup_type}' = 'all' ]; then 
  zipfile='{remote_tmp}/mods-'$(date +%d-%m-%Y-%H-%M)'.zip';
  # –°–æ–∑–¥–∞—ë–º db_mods.json
  python3 -c "import json; db=json.load(open('config-$tg_id.json')); db_mods=db.get('LoaderMod',{{}}).get('loaded_modules',{{}}); open('db_mods.json','w').write(json.dumps(db_mods,ensure_ascii=True,separators=(', ', ': ')));"
  mods_files=$(ls loaded_modules/*${{tg_id}}.py 2>/dev/null || true)
  if [ -n "$mods_files" ]; then
    zip -j "$zipfile" $mods_files db_mods.json >/dev/null 2>&1
  else
    zip -j "$zipfile" db_mods.json >/dev/null 2>&1
  fi
  rm -f db_mods.json
fi
if [ '{backup_type}' = 'all' ]; then 
  allzip='{remote_tmp}/backup-all-'$(date +%d-%m-%Y-%H-%M)'.zip';
  dbfile=$(ls {remote_tmp}/db-backup-*.json | head -n1)
  modsfile=$(ls {remote_tmp}/mods-*.zip | head -n1)
  cp "$dbfile" {remote_tmp}/db.json
  cp "$modsfile" {remote_tmp}/mods.zip
  zip -j "$allzip" {remote_tmp}/db.json {remote_tmp}/mods.zip >/dev/null 2>&1 || true
fi
ls -1 {remote_tmp}
'''
    # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∫—Ä–∏–ø—Ç –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ
    res = await run_command_async(f"bash -x -c {shlex.quote(remote_script)}", server_ip, check_output=False)
    if not res.get("success") or "NO_TGID" in res.get("output",""):
        raise FileNotFoundError(f"–ù–µ –Ω–∞–π–¥–µ–Ω —Ñ–∞–π–ª config-<tg_id>.json –∏–ª–∏ tg_id –≤ {hikka_path}")
    # 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è –∞—Ä—Ö–∏–≤–∞
    files = res.get("output","").splitlines()
    if backup_type == "all":
        archive_name = next((f for f in files if f.startswith("backup-all-") and f.endswith(".zip")), None)
    elif backup_type == "mods":
        archive_name = next((f for f in files if f.startswith("mods-") and f.endswith(".zip")), None)
    elif backup_type == "db":
        archive_name = next((f for f in files if f.startswith("db-backup-") and f.endswith(".json")), None)
    else:
        archive_name = None
    if not archive_name:
        raise RuntimeError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞—Ä—Ö–∏–≤ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –±—ç–∫–∞–ø–∞. –§–∞–π–ª—ã: {files}\nSTDOUT: {res.get('output','')}\nSTDERR: {res.get('error','')}")
    remote_archive = f"{remote_tmp}/{archive_name}"
    # 3. –°–∫–∞—á–∏–≤–∞–µ–º –∞—Ä—Ö–∏–≤ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ SFTP
    import asyncssh
    servers = server_config.get_servers()
    server_details = servers.get(server_ip)
    if not server_details:
        raise RuntimeError(f"SSH details not found for server {server_ip}")
    ssh_user = server_details.get("ssh_user")
    ssh_pass = server_details.get("ssh_pass")
    local_tmp = tempfile.NamedTemporaryFile(delete=False)
    local_tmp.close()
    try:
        async with asyncssh.connect(server_ip, username=ssh_user, password=ssh_pass, known_hosts=None) as conn:
            async with conn.start_sftp_client() as sftp:
                await sftp.get(remote_archive, local_tmp.name)
    except Exception as e:
        import logging
        logging.error(f"[heroku_backup] SFTP download error: {e}")
        raise RuntimeError(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∞—Ä—Ö–∏–≤ —Å —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ —á–µ—Ä–µ–∑ SFTP: {e}")
    # 4. –£–¥–∞–ª—è–µ–º –∞—Ä—Ö–∏–≤ –∏ –≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–∞–ø–∫—É –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ
    await run_command_async(f"rm -rf {remote_tmp}", server_ip, check_output=False)
    return local_tmp.name, archive_name

# ... existing code ...
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ zipfile.py* –≤ –ø—Ä–æ–µ–∫—Ç–µ, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É –º–æ–¥—É–ª—é
    check_zipfile_cmd = f"find {shlex.quote(hikka_path)} -name 'zipfile.py*' | head -n1"
    check_res = await run_command_async(check_zipfile_cmd, server_ip, check_output=True)
    if check_res.get('output', '').strip():
        raise RuntimeError(
            f"–í –ø–∞–ø–∫–µ –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞–π–¥–µ–Ω —Ñ–∞–π–ª zipfile.py –∏–ª–∏ zipfile.pyc: {check_res['output'].strip()}\n"
            "–≠—Ç–æ –º–µ—à–∞–µ—Ç —Ä–∞–±–æ—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –º–æ–¥—É–ª—è Python. –ü–µ—Ä–µ–∏–º–µ–Ω—É–π—Ç–µ –∏–ª–∏ —É–¥–∞–ª–∏—Ç–µ —ç—Ç–æ—Ç —Ñ–∞–π–ª –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –±—ç–∫–∞–ø–∞."
        )
# ... existing code ...

async def get_service_process_uptime(service_name: str, server_ip: str) -> str | None:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–ø—Ç–∞–π–º –ø—Ä–æ—Ü–µ—Å—Å–∞ (–≤ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ) –¥–ª—è systemd-—Å–µ—Ä–≤–∏—Å–∞ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ.
    –ï—Å–ª–∏ —Å–µ—Ä–≤–∏—Å –Ω–µ –∑–∞–ø—É—â–µ–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None.
    """
    # –ü–æ–ª—É—á–∞–µ–º MainPID
    cmd_pid = f"systemctl show {service_name} -p MainPID"
    res_pid = await run_command_async(cmd_pid, server_ip, check_output=True)
    if not res_pid.get("success") or not res_pid.get("output"):
        return None
    try:
        pid_line = res_pid["output"].strip()
        pid = int(pid_line.split('=')[1])
        if pid == 0:
            return None
    except Exception:
        return None
    # –ü–æ–ª—É—á–∞–µ–º –∞–ø—Ç–∞–π–º –ø—Ä–æ—Ü–µ—Å—Å–∞ —á–µ—Ä–µ–∑ ps
    cmd_uptime = f"ps -o etime= -p {pid}"
    res_uptime = await run_command_async(cmd_uptime, server_ip, check_output=True)
    if not res_uptime.get("success") or not res_uptime.get("output"):
        return None
    return res_uptime["output"].strip()

async def fix_existing_users_tmp_access(server_ip: str):
    """
    –ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ /tmp/isolated –¥–ª—è –≤—Å–µ—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    """
    fix_isolated_cmd = """
    sudo chmod 755 /tmp/isolated 2>/dev/null || true
    sudo chown root:root /tmp/isolated 2>/dev/null || true
    sudo setfacl -b /tmp/isolated 2>/dev/null || true
    sudo find /tmp/isolated -type d -maxdepth 1 -exec chmod 755 {} \\; 2>/dev/null || true
    sudo find /tmp/isolated -type d -maxdepth 1 -exec chown root:root {} \\; 2>/dev/null || true
    """
    await run_command_async(fix_isolated_cmd, server_ip, check_output=False)
    logging.info(f"Fixed /tmp/isolated permissions on {server_ip}")



