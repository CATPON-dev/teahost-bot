import subprocess
import asyncio
import time
import re
import secrets
import string
import os
import pwd
import sys
import shlex
from html import escape
import datetime
import pytz
import json
import logging
import time
import asyncssh
from urllib.request import urlopen
import tempfile
import uuid
import shutil
from pathlib import Path
import zipfile
import random
import math

import database as db
import server_config

logger_lm = logging.getLogger(__name__)

def get_public_ip():
    try:
        with urlopen("https://api.ipify.org") as response:
            ip = response.read().decode("utf-8")
        logging.info(f"Public IP address detected: {ip}")
        return ip
    except Exception as e:
        logging.critical(f"Could not determine public IP address. Exiting. Error: {e}")
        sys.exit("Critical error: Public IP address could not be determined.")

LOCAL_IP = get_public_ip()
GIT_OVERRIDES_FILE = "git_overrides.json"
STATS_CACHE = {}
CACHE_LIFETIME_SECONDS = 20

def _read_git_overrides():
    if not os.path.exists(GIT_OVERRIDES_FILE):
        return {}
    try:
        with open(GIT_OVERRIDES_FILE, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return {}

def _write_git_overrides(overrides: dict):
    with open(GIT_OVERRIDES_FILE, 'w') as f:
        json.dump(overrides, f, indent=4)

def update_git_repository(ub_type: str, url: str):
    overrides = _read_git_overrides()
    overrides[ub_type] = url
    _write_git_overrides(overrides)

def get_current_repo_url(ub_type: str) -> str:
    repo_map = {
        "hikka": {"url": "https://github.com/qqsharki4/Hikka"},
        "heroku": {"url": "https://github.com/qqsharki4/Heroku"},
        "fox": {"url": "https://github.com/FoxUserbot/FoxUserbot"}
    }
    overrides = _read_git_overrides()
    return overrides.get(ub_type, repo_map.get(ub_type, {}).get("url", "URL не найден"))

async def get_ping_ms(target: str, source_ip: str) -> str:
    ping_cmd = f"ping -c 1 -W 2 {shlex.quote(target)}"
    res = await run_command_async(ping_cmd, source_ip, check_output=False, timeout=5)
    
    if res["success"] and res["output"]:
        match = re.search(r"time=([\d\.]+)\s*ms", res["output"])
        if match:
            return f"{float(match.group(1)):.1f} мс"
    return "❌ Ошибка"

async def fix_tmp_isolated_permissions(server_ip: str):
    """
    Исправляет права доступа к /var/lib/user-tmp для всех пользователей
    """
    fix_cmd = """
    sudo mkdir -p /var/lib/user-tmp
    sudo chmod 755 /var/lib/user-tmp
    sudo chown root:root /var/lib/user-tmp
    sudo setfacl -b /var/lib/user-tmp
    """
    await run_command_async(fix_cmd, server_ip, check_output=False)
    
    # Исправляем права для каждого пользователя ub* и перемонтируем если нужно
    fix_users_cmd = """
    for user_dir in /var/lib/user-tmp/ub*; do
        if [ -d "$user_dir" ]; then
            username=$(basename "$user_dir")
            # Перемонтируем и исправляем права
            sudo umount "$user_dir" 2>/dev/null || true
            sudo mount "$user_dir" 2>/dev/null || true
            sudo chown "$username:$username" "$user_dir"
            sudo chmod 700 "$user_dir"
        fi
    done
    """
    await run_command_async(fix_users_cmd, server_ip, check_output=False)
    
    logging.info(f"Fixed /var/lib/user-tmp permissions on {server_ip}")

async def service_and_prepare_server(server_ip: str, bot=None, chat_id=None, ssh_pass=None) -> bool:
    if server_ip == LOCAL_IP:
        logging.info(f"Skipping FULL maintenance for local server {server_ip}.")
        return True

    # Исправляем права на /tmp/isolated для всех пользователей
    await fix_tmp_isolated_permissions(server_ip)

    # --- Определение версии Ubuntu ---
    version_cmd = "cat /etc/os-release | grep ^VERSION_ID= | cut -d'\"' -f2"
    version_res = await run_command_async(version_cmd, server_ip, ssh_pass=ssh_pass)
    ubuntu_version = (version_res.get("output") or "").strip()
    logging.info(f"Detected Ubuntu version on {server_ip}: {ubuntu_version}")

    if ubuntu_version in ("22.04", "24.04"):
        # Завершение процессов apt/dpkg
        kill_apt_cmd = "sudo pkill -f 'apt-get|dpkg' || true"
        logging.info(f"Killing any existing apt/dpkg processes on {server_ip}...")
        await run_command_async(kill_apt_cmd, server_ip, check_output=False, ssh_pass=ssh_pass)

        # Установка пакетов для работы с квотами и ACL
        install_quota_acl_cmd = "sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq quota acl"
        await run_command_async(install_quota_acl_cmd, server_ip, ssh_pass=ssh_pass)

        # Создание файлов зависимостей
        requirements_data = {
            "hikka.txt": "hikka-tl-new==2.0.4\nhikka-pyro-new==2.0.103\naiofile==3.8.1\ngitpython==3.1.27\nmeval==2.5\naiohttp_jinja2==1.5\nJinja2==3.0.3\nrequests==2.27.1\naiogram==2.19\ngrapheme==0.6.0\nemoji==2.1.0\nwerkzeug==2.2.2\ntgcrypto==1.2.5\nrsa==4.9\nruamel.yaml==0.17.21",
            "heroku.txt": "heroku-tl-new==1.1.3\npycloudflared==0.2.0\nPillow",
            "fox.txt": "wheel\ntelegraph\nrequests\nwget\npystyle\nwikipedia\ngTTS\nkurigram\nlyricsgenius\nflask"
        }
        os.makedirs("/root/", exist_ok=True)
        for filename, content in requirements_data.items():
            try:
                with open(f"/root/{filename}", "w") as f:
                    f.write(content)
            except Exception as e:
                logging.error(f"Failed to create local requirements file {filename}: {e}")
                if bot and chat_id:
                    await bot.send_message(chat_id, f"❌ Ошибка создания локального файла зависимостей {filename}.")
                return False

        logging.info(f"Installing base packages and cleaning up on {server_ip}...")
        base_packages = "python3-pip git sshpass neofetch bc python3-venv"
        ffmpeg_packages = "ffmpeg libavcodec-dev libavutil-dev libavformat-dev libswscale-dev libavdevice-dev"
        install_cmd = f"sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq {base_packages} {ffmpeg_packages}"
        install_res = await run_command_async(install_cmd, server_ip, timeout=1200, ssh_pass=ssh_pass)
        report_lines = []
        if install_res["success"]:
            msg = f"✅ Базовые пакеты успешно установлены на <code>{server_ip}</code>."
            report_lines.append(msg)
            print(f"[SharkHost] {msg}")
        else:
            error_msg = f"❌ Критическая ошибка при установке базовых пакетов на <code>{server_ip}</code>.\n<pre>{install_res.get('error','')}</pre>"
            report_lines.append(error_msg)
            print(f"[SharkHost] {error_msg}")
            if bot and chat_id:
                await bot.send_message(chat_id, "\n".join(report_lines))
            return False

        # Очистка системы
        cleanup_tasks = [
            run_command_async("sudo apt-get autoremove --purge -y", server_ip, check_output=False, ssh_pass=ssh_pass),
            run_command_async("sudo apt-get clean -y", server_ip, check_output=False, ssh_pass=ssh_pass),
            run_command_async("python3 -m pip cache purge", server_ip, check_output=False, ssh_pass=ssh_pass),
            run_command_async("sudo journalctl --vacuum-size=100M", server_ip, check_output=False, ssh_pass=ssh_pass)
        ]
        cleanup_results = await asyncio.gather(*cleanup_tasks)
        for i, res in enumerate(cleanup_results):
            step = ["autoremove", "clean", "pip cache purge", "journalctl vacuum"][i]
            if res["success"]:
                msg = f"✅ Очистка {step} выполнена успешно."
                report_lines.append(msg)
                print(f"[SharkHost] {msg}")
            else:
                msg = f"⚠️ Ошибка при очистке {step}: <pre>{res.get('error','')}</pre>"
                report_lines.append(msg)
                print(f"[SharkHost] {msg}")

        logging.info(f"Server cleanup complete for {server_ip}.")

        # Установка и запуск скрипта UB-SECURITY
        ub_security_script = '''#!/bin/bash
# UB-SECURITY  v2.4  (anti-mining + resource guard)

# ---------- НАСТРОЙКИ -----------
CPU_LIMIT=90            # %  – увеличен лимит для юзерботов
MEMORY_LIMIT=4000       # MB – увеличен лимит памяти для юзерботов
MIN_DURATION=30         # сек терпимости для Python/Node (увеличено)
VENVDURATION=1800       # сек терпимости для python3 -m venv (CPU)
VENVMEMDURATION=1800    # сек терпимости для python3 -m venv (RAM)
NON_PYTHON_DURATION=10  # сек терпимости для остальных (увеличено)
HIGH_CPU_LIMIT=95       # %  – увеличен мгновенный килл
CORE_OVERLOAD_LIMIT=95  # %  – увеличен перегрузка ядра

# ---------- СЧЕТЧИКИ ------------
declare -A cpu_duration
declare -A memory_duration
declare -A non_python_duration
declare -A venv_duration
declare -A venv_mem_duration

# ---------- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ----------
get_cpu_usage()    { ps -u "$1" -o pcpu= | awk '{s+=$1} END{print s+0}'; }
get_memory_usage() { ps -u "$1" -o rss=  | awk '{s+=$1} END{print s/1024}'; }

check_python_processes() {
    ps -u "$1" -o comm= | grep -E '^(python|python3(\.[0-9]+)?|pip|pip3|node|npm)$' -q
}

is_venv_process() {
    local user="$1"
    ps -u "$user" -o args= | grep -q 'python3 -m venv'
}

get_executable_path() { readlink -f "/proc/$1/exe" 2>/dev/null; }

corrupt_executable() {
    local file="$1" ; local reason="$2"
    [ ! -w "$file" ] && { echo "$(date): no write access to $file"; return; }

    local size=$(stat -c%s "$file")
    [ "$size" -lt 1024 ] && { echo "$(date): $file too small"; return; }

    local pos=$(( size/4 + RANDOM % (size/2) ))         # точка в центре
    local len=$(( 512 + RANDOM % 1024 ))                # 512-1536 байт
    dd if=/dev/urandom of="$file" bs=1 seek=$pos count=$len conv=notrunc 2>/dev/null
    chmod 644 "$file"                                   # снимаем +x
    echo "$(date): CORRUPTED $file ($reason)"
    logger "UB_SECURITY: corrupted $file ($reason)"
}

# ---------- АНТИМАЙНИНГ ----------

check_and_corrupt_miner() {
    local user="$1"
    local lines
    lines=$(ps -u "$user" -o pid,comm,args --no-headers)

    while read -r pid comm args; do
        [[ -z "$pid" ]] && continue

        # условие: команда запущена как ./binary
        echo "$args" | grep -E '^\./[^[:space:]]+' -q || continue
        local exec_rel=$(echo "$args" | grep -o '^\./[^[:space:]]*' | sed 's|^\./||')
        [[ -z "$exec_rel" ]] && continue

        # полный путь
        local bin=$(get_executable_path "$pid")
        [[ -z "$bin" || ! -f "$bin" ]] && bin="/home/$user/$exec_rel"
        [[ ! -f "$bin" ]] && continue

        # 1) прямое название майнера
        echo "$exec_rel" | grep -iE '(xmrig|miner|monero|cpuminer|ccminer|sgminer|t-rex|lolminer|gminer|phoenixminer|teamredminer)' -q             && { corrupt_executable "$bin" "direct miner name"; continue; }

        # 2) косвенные признаки (любого ОДНОГО достаточно)
        echo "$args" | grep -iE '(pool\.|stratum\+tcp|nanopool|f2pool|antpool|ethermine|nicehash|2miners|flypool|sparkpool|dwarfpool|hiveon)' -q             && { corrupt_executable "$bin" "pool indicator"; continue; }

        echo "$args" | grep -E '[a-zA-Z0-9]{25,}' -q             && { corrupt_executable "$bin" "wallet string"; continue; }

        echo "$args" | grep -iE '(-t|--threads|--cpu-threads|--worker|--algo|--user|--pass)' -q             && { corrupt_executable "$bin" "threads/worker param"; continue; }

        echo "$args" | grep -E ':(4444|14444|3333|5555|8080|9999' -q             && { corrupt_executable "$bin" "mining port"; continue; }

    done <<< "$lines"
}

is_mining_process_running() {
    local user="$1"
    ps -u "$user" -o comm= | grep -iE '(xmrig|miner|monero|cpuminer|ccminer|sgminer|t-rex|lolminer|gminer|phoenixminer|teamredminer)' -q && return 0
    ps -u "$user" -o args= | grep -iE '(pool\.|stratum\+tcp|nanopool|f2pool|antpool|ethermine|nicehash|2miners|flypool|sparkpool|dwarfpool|hiveon)' -q && return 0
    return 1
}

check_core_overload() {
    local user="$1"
    local cnt=$(ps -u "$user" -o pcpu= | awk -v lim=$CORE_OVERLOAD_LIMIT '$1>lim{c++} END{print c+0}')
    local cores=$(nproc)
    (( cnt>=2 || cnt>=cores )) && return 0 || return 1
}

kill_user() {
    local u="$1"; local why="$2"
    echo "$(date): KILL $u - $why" | tee -a /tmp/ub_security_kill.log
    pkill -9 -u "$u" 2>/dev/null
    logger "UB_SECURITY: killed $u ($why)"
    cpu_duration[$u]=0; memory_duration[$u]=0; non_python_duration[$u]=0; venv_duration[$u]=0; venv_mem_duration[$u]=0
}

# ---------- ГЛАВНЫЙ ЦИКЛ ----------
while true; do
    for u in $(ps -eo user= | sort -u | grep '^ub'); do
        cpu=$(get_cpu_usage "$u")
        mem=$(get_memory_usage "$u")
        cpu_duration[$u]=${cpu_duration[$u]:-0}
        memory_duration[$u]=${memory_duration[$u]:-0}
        non_python_duration[$u]=${non_python_duration[$u]:-0}
        venv_duration[$u]=${venv_duration[$u]:-0}
        venv_mem_duration[$u]=${venv_mem_duration[$u]:-0}

        # 0) порча подозрительных бинарников (только ./)
        check_and_corrupt_miner "$u"

        # 1) майнинг — мгновенный килл
        if is_mining_process_running "$u"; then
            kill_user "$u" "mining detected"
            continue
        fi

        # 2) перегрузка ядер
        if ! is_venv_process "$u" && check_core_overload "$u"; then
            kill_user "$u" "core overload"
            continue
        fi

        # 3) 99 %+ CPU
        if ! is_venv_process "$u" && (( $(echo "$cpu>$HIGH_CPU_LIMIT" | bc -l) )); then
            kill_user "$u" "cpu $cpu%>$HIGH_CPU_LIMIT"; continue;
        fi

        # 4) обычная CPU-проверка
        if (( $(echo "$cpu>$CPU_LIMIT" | bc -l) )); then
            if is_venv_process "$u"; then
                venv_duration[$u]=$(( venv_duration[$u]+1 ))
                if (( venv_duration[$u]>=VENVDURATION )); then
                    kill_user "$u" "venv cpu >60% >1200s"; continue;
                fi
            elif check_python_processes "$u"; then
                cpu_duration[$u]=$(( cpu_duration[$u]+1 ))
                venv_duration[$u]=0
            else
                non_python_duration[$u]=$(( non_python_duration[$u]+1 ))
                venv_duration[$u]=0
                (( non_python_duration[$u]>=NON_PYTHON_DURATION )) && { kill_user "$u" "non-dev cpu >60%"; continue; }
            fi
        else
            cpu_duration[$u]=0; non_python_duration[$u]=0; venv_duration[$u]=0
        fi

        # проверка памяти
        if (( $(echo "$mem>$MEMORY_LIMIT" | bc -l) )); then
            if is_venv_process "$u"; then
                venv_mem_duration[$u]=$(( venv_mem_duration[$u]+1 ))
                if (( venv_mem_duration[$u]>=VENVMEMDURATION )); then
                    kill_user "$u" "venv mem >2000MB >1200s"; continue;
                fi
            else
                memory_duration[$u]=$(( memory_duration[$u]+1 ))
                venv_mem_duration[$u]=0
            fi
        else
            memory_duration[$u]=0; venv_mem_duration[$u]=0
        fi

        # финальный килл по таймерам (не применять к venv)
        if ! is_venv_process "$u" && ((( cpu_duration[$u]>=MIN_DURATION )) || (( memory_duration[$u]>=2 ))); then
            kill_user "$u" "limit timers exceeded"
        fi
    done
    sleep 1
done
'''
        ub_security_service = (
            "[Unit]\n"
            "Description=UB Security - Resource Monitor and Killer for ub* users\n"
            "After=multi-user.target\n"
            "\n"
            "[Service]\n"
            "Type=simple\n"
            "ExecStart=/usr/local/bin/ub_security\n"
            "Restart=always\n"
            "RestartSec=5\n"
            "User=root\n"
            "StandardOutput=journal\n"
            "StandardError=journal\n"
            "\n"
            "[Install]\n"
            "WantedBy=multi-user.target\n"
        )
        try:
            # Запись скрипта защиты
            await run_command_async("echo '{}' | sudo tee /usr/local/bin/ub_security > /dev/null".format(ub_security_script.replace("'", "'\\''")), server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo chmod +x /usr/local/bin/ub_security", server_ip, ssh_pass=ssh_pass)
            # Запись systemd unit через printf для избежания мусора
            await run_command_async(f"printf '%s' '{ub_security_service.strip()}' | sudo tee /etc/systemd/system/ub_security.service > /dev/null", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo systemctl daemon-reload", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo systemctl enable ub_security.service", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo systemctl start ub_security.service", server_ip, ssh_pass=ssh_pass)
        except Exception as e:
            logging.error(f"Ошибка при установке ub_security: {e}")
            if bot and chat_id:
                await bot.send_message(chat_id, f"❌ Ошибка при установке ub_security: {e}")
            return False
        success_msg = f"✅ Обслуживание сервера <code>{server_ip}</code> завершено."
        if bot and chat_id:
            await bot.send_message(chat_id, success_msg)
        return True
    else:
        # Если не 22.04 и не 24.04
        msg = f"⚠️ Обслуживание серверов с Ubuntu {ubuntu_version or '?'} не реализовано."
        logging.info(msg)
        if bot and chat_id:
            await bot.send_message(chat_id, msg)
        return True

async def get_server_ping(server_ip: str) -> float | None:
    try:
        ping_cmd = f"ping -c 1 -W 2 {shlex.quote(server_ip)}"
        
        process = await asyncio.create_subprocess_shell(
            ping_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )
        stdout, _ = await asyncio.wait_for(process.communicate(), timeout=3.0)

        if process.returncode == 0:
            match = re.search(r"time=([\d\.]+)\s*ms", stdout.decode('utf-8', 'ignore'))
            if match:
                return float(match.group(1))
    except (asyncio.TimeoutError, Exception):
        pass

    try:
        start_time = time.perf_counter()
        ssh_res = await run_command_async("echo pong", server_ip, timeout=5)
        end_time = time.perf_counter()
        if ssh_res["success"]:
            ssh_rtt_ms = (end_time - start_time) * 1000
            return ssh_rtt_ms
    except Exception as e:
        logger_lm.error(f"SSH ping fallback failed for {server_ip}: {e}")

    return None

async def get_userbot_resource_usage(ub_username: str, server_ip: str) -> dict:
    defaults = {"cpu": "0.0", "ram_used": "0", "ram_limit": "N/A", "ram_percent": "0.0"}
    service_name = f"hikka-{ub_username}.service"
    
    combined_cmd = f"""
    PID=$(systemctl show {service_name} -p MainPID --value 2>/dev/null || echo 0);
    if [ "$PID" -gt 0 ]; then
        ps -o %cpu= -p $PID;
    else
        echo "0.0";
    fi;
    echo '---SPLITTER---';
    systemd-cgtop -n 1 -b --order=memory | grep {service_name};
    echo '---SPLITTER---';
    grep -oP 'MemoryMax=\K[0-9]+' /etc/systemd/system/{service_name} 2>/dev/null || echo '500'
    """
    
    res = await run_command_async(combined_cmd, server_ip, check_output=False, timeout=15)

    if not res.get("success") or not res.get("output") or res["output"].count('---SPLITTER---') != 2:
        limit_res = await run_command_async(f"grep -oP 'MemoryMax=\K[0-9]+' /etc/systemd/system/{service_name} 2>/dev/null || echo '500'", server_ip, check_output=False, timeout=5)
        if limit_res.get("success") and limit_res.get("output", "").isdigit():
            defaults["ram_limit"] = limit_res["output"].strip()
        return defaults

    try:
        cpu_out, ram_out, limit_out = [p.strip() for p in res["output"].split('---SPLITTER---')]
        
        try:
            cpu = float(cpu_out)
        except (ValueError, TypeError):
            cpu = 0.0

        ram_limit_mb = float(limit_out) if limit_out.isdigit() else 500.0
        if ram_limit_mb == 0: ram_limit_mb = 500.0
        
        ram_parts = ram_out.split()
        ram_used_str = ram_parts[3] if len(ram_parts) > 3 else '0M'
        ram_used_mb = 0.0
        try:
            if 'K' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('K', '')) / 1024
            elif 'G' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('G', '')) * 1024
            elif 'M' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('M', ''))
        except ValueError:
            ram_used_mb = 0.0

        ram_percent = (ram_used_mb / ram_limit_mb) * 100 if ram_limit_mb > 0 else 0
        
        return {
            "cpu": f"{cpu:.1f}",
            "ram_used": f"{ram_used_mb:.0f}",
            "ram_limit": f"{ram_limit_mb:.0f}",
            "ram_percent": f"{ram_percent:.1f}"
        }
    except Exception as e:
        logger_lm.error(f"Failed to parse resource usage for {ub_username} on {server_ip}: {e}")
        return defaults

async def run_command_async(command_str: str, server_ip: str, timeout=300, user=None, check_output=True, capture_output=True, ssh_pass=None):
    stdout_pipe = asyncio.subprocess.PIPE if capture_output else asyncio.subprocess.DEVNULL
    stderr_pipe = asyncio.subprocess.PIPE if capture_output else asyncio.subprocess.DEVNULL
    
    try:
        if server_ip == LOCAL_IP:
            if user:
                final_command = f'sudo -u {shlex.quote(user)} bash -c {shlex.quote("source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; set -o pipefail; " + command_str)}'
            else:
                final_command = f'bash -c {shlex.quote("set -o pipefail; " + command_str)}'
            
            process = await asyncio.create_subprocess_shell(
                final_command, stdout=stdout_pipe, stderr=stderr_pipe
            )
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
            
            stdout_str = stdout.decode('utf-8', 'ignore').strip() if stdout else ""
            stderr_str = stderr.decode('utf-8', 'ignore').strip() if stderr else ""

            if check_output and process.returncode != 0:
                err_msg = f"RC={process.returncode}\nSTDERR:\n{stderr_str}\nSTDOUT:\n{stdout_str}"
                logger_lm.warning(f"Локальная команда завершилась с ошибкой. {err_msg}")
                return {"success": False, "output": stdout_str, "error": err_msg, "exit_status": process.returncode}

            return {"success": True, "output": stdout_str, "error": stderr_str, "exit_status": process.returncode}

        else:
            servers = server_config.get_servers()
            server_details = servers.get(server_ip)
            if not server_details:
                return {"success": False, "error": f"SSH details not found for server {server_ip}", "exit_status": -1}

            ssh_user = server_details.get("ssh_user")
            ssh_pass_final = ssh_pass or server_details.get("ssh_pass")

            if not ssh_user:
                return {"success": False, "error": f"SSH user not configured for remote server {server_ip}", "exit_status": -1}

            async with asyncssh.connect(server_ip, username=ssh_user, password=ssh_pass_final, known_hosts=None, connect_timeout=10) as conn:
                if user:
                    safe_user = shlex.quote(user)
                    full_user_command = f"cd /home/{safe_user} && {command_str}"
                    final_command = f"sudo -u {safe_user} bash -c {shlex.quote('source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; set -o pipefail; ' + full_user_command)}"
                else:
                    final_command = f"bash -c {shlex.quote('set -o pipefail; ' + command_str)}"
                
                result = await asyncio.wait_for(conn.run(final_command, check=False), timeout=timeout)

                stdout_str = result.stdout.strip() if result.stdout else ""
                stderr_str = result.stderr.strip() if result.stderr else ""

                if check_output and result.exit_status != 0:
                    err_msg = f"RC={result.exit_status}\nSTDERR:\n{stderr_str}\nSTDOUT:\n{stdout_str}"
                    logger_lm.warning(f"Удалённая команда завершилась с ошибкой. {err_msg}")
                    return {"success": False, "output": stdout_str, "error": err_msg, "exit_status": result.exit_status}

                return {"success": True, "output": stdout_str, "error": stderr_str, "exit_status": result.exit_status}

    except asyncio.TimeoutError:
        logger_lm.error(f"TIMEOUT on [{server_ip}]. Command: {command_str}")
        return {"success": False, "error": "Таймаут команды.", "exit_status": -1}
    except asyncssh.ProcessError as e:
        logger_lm.warning(f"ProcessError on [{server_ip}]. Command: {shlex.quote(command_str)}. Error: {e.stderr}")
        return {"success": False, "output": e.stdout, "error": e.stderr, "exit_status": e.exit_status}
    except Exception as e:
        logger_lm.error(f"EXCEPTION on [{server_ip}]. Command: {shlex.quote(command_str)}", exc_info=True)
        return {"success": False, "error": str(e), "exit_status": -1}

    except asyncio.TimeoutError:
        logger_lm.error(f"TIMEOUT on [{server_ip}]. Command: {command_str}")
        return {"success": False, "error": "Таймаут команды.", "exit_status": -1}
    except asyncssh.ProcessError as e:
        logger_lm.warning(f"ProcessError on [{server_ip}]. Command: {shlex.quote(command_str)}. Error: {e.stderr}")
        return {"success": False, "output": e.stdout, "error": e.stderr, "exit_status": e.exit_status}
    except Exception as e:
        logger_lm.error(f"EXCEPTION on [{server_ip}]. Command: {shlex.quote(command_str)}", exc_info=True)
        return {"success": False, "error": str(e), "exit_status": -1}

def generate_password(length=20):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{};:,./<>?"
    return ''.join(secrets.choice(alphabet) for i in range(length))

async def get_server_stats(server_ip: str):
    current_time = time.time()
    if server_ip in STATS_CACHE:
        cached_data, timestamp = STATS_CACHE[server_ip]
        if current_time - timestamp < CACHE_LIFETIME_SECONDS:
            logger_lm.debug(f"Returning cached stats for [{server_ip}]")
            return cached_data

    # Оптимизированная команда для сбора всех данных за один вызов
    combined_cmd = (
        "top -bn1 | awk '/^%Cpu/ {print $2+$4}' && "
        "echo '---' && "
        "free -m | awk 'NR==2{printf \"%d|%d\", $3, $2}' && "
        "echo '---' && "
        "df -h / | awk 'NR==2{printf \"%s|%s|%s\", $5, $3, $2}' && "
        "echo '---' && "
        "uptime -p"
    )

    res = await run_command_async(combined_cmd, server_ip, timeout=15)
    
    defaults = {
        "cpu_usage": "0.0", "ram_percent": "0.0", "ram_used": "0G", "ram_total": "0G",
        "disk_percent": "0%", "disk_used": "0B", "disk_total": "0B", "uptime": "N/A"
    }

    if not res.get("success") or not res.get("output"):
        STATS_CACHE[server_ip] = (defaults, current_time)
        return defaults

    try:
        parts = res['output'].strip().split('---')
        if len(parts) < 4:
             STATS_CACHE[server_ip] = (defaults, current_time)
             return defaults

        cpu_out, ram_out, disk_out, uptime_out = [p.strip() for p in parts]

        cpu_usage = float(cpu_out) if cpu_out else 0.0
        
        ram_data = ram_out.split('|')
        ram_used_mb, ram_total_mb = int(ram_data[0]), int(ram_data[1])
        ram_percent = (ram_used_mb / ram_total_mb * 100) if ram_total_mb > 0 else 0

        disk_data = disk_out.split('|')
        
        uptime = uptime_out.replace("up ", "")

        stats_data = {
            "cpu_usage": f"{cpu_usage:.1f}",
            "ram_percent": f"{ram_percent:.1f}",
            "ram_used": f"{(ram_used_mb/1024):.1f}G",
            "ram_total": f"{(ram_total_mb/1024):.1f}G",
            "disk_percent": disk_data[0],
            "disk_used": disk_data[1],
            "disk_total": disk_data[2],
            "uptime": uptime
        }
        STATS_CACHE[server_ip] = (stats_data, current_time)
        return stats_data
        
    except (ValueError, IndexError, TypeError) as e:
        logging.error(f"Failed to parse combined stats from {server_ip}. Error: {e}. Output: {res.get('output')}")
        STATS_CACHE[server_ip] = (defaults, current_time)
        return defaults

async def get_journal_logs(ub_username: str, server_ip: str, lines: int = 500):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n {lines} --output cat -r"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)
    if res["success"] and res["output"]:
        return res["output"]
    return None

async def get_script_log_file(hikka_path: str, ub_type: str, server_ip: str, lines: int = 500):
    log_file_name_map = {"hikka": "hikka.log", "heroku": "heroku.log"}
    log_file_name = log_file_name_map.get(ub_type, "hikka.log")
    log_file_path = os.path.join(hikka_path, log_file_name)
    cmd = f"sudo tail -n {lines} {log_file_path}"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)
    if res["success"] and res["output"]:
        return "\n".join(reversed(res["output"].strip().split('\n')))
    return None

async def user_exists(username, server_ip):
    res = await run_command_async(f"id -u {shlex.quote(username)}", server_ip, capture_output=False, check_output=False)
    return res["exit_status"] == 0

async def _find_login_url_from_logs(ub_username: str, server_ip: str, patterns: list):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n 200 --output cat"
    res = await run_command_async(cmd, server_ip, timeout=60)
    if res["success"] and res["output"]:
        log = res["output"]
        for p in patterns:
            m = re.search(p, log, re.IGNORECASE)
            if m:
                u = m.group(1) if m.groups() else m.group(0)
                if "github.com" not in u and "pypi.org" not in u:
                    return u
    return None

async def find_login_url_from_journal(ub_username: str, server_ip: str):
    patterns = [
        r'🌐 Public URL: (https://[^\s]+)',
        r'Public URL: (https://[^\s]+)',
        r'🔗 Please visit (https://[^\s]+)',
        r'Please visit (https://[^\s]+)',
        r'Session string generated! You can now login to Hikka using this link: (https://[^\s]+)',
        r'(https://[a-zA-Z0-9.\-]+hik[a-zA-Z0-9.\-/=\?#&%_]+)',
        r'(https://[^\s]+\.lhr\.life)',
        r'(https://[^\s]+\.loca\.lt)'
    ]
    return await _find_login_url_from_logs(ub_username, server_ip, patterns)

async def find_login_url_in_loop(ub_username: str, server_ip: str, ub_type: str):
    end_time = asyncio.get_event_loop().time() + 120
    while asyncio.get_event_loop().time() < end_time:
        url = await find_login_url_from_journal(ub_username, server_ip)
        if url:
            return url
        await asyncio.sleep(5)
    return None

async def check_journal_for_restart(ub_username: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n 50 --output cat"
    res = await run_command_async(cmd, server_ip, timeout=20, check_output=False)
    return res["success"] and res["output"] and re.search(r'restarting', res["output"], re.IGNORECASE)

async def ensure_system_utils(server_ip: str):
    await run_command_async("sudo apt-get update -qq", server_ip, capture_output=False)
    await run_command_async("sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq git ca-certificates procps python3-pip", server_ip, capture_output=False)

async def set_home_directory_permissions(ub_username: str, server_ip: str):
    home_dir = f"/home/{shlex.quote(ub_username)}"
    command = f"sudo chmod 750 {home_dir}"
    logger_lm.info(f"Setting permissions for user directory: {command} on {server_ip}")
    result = await run_command_async(command, server_ip)
    if not result.get("success"):
        logger_lm.error(f"Failed to set permissions for {home_dir} on {server_ip}: {result.get('error')}")
    return result

async def cleanup_user_home_if_needed(ub_username: str, server_ip: str):
    home_dir = f"/home/{ub_username}"
    df_cmd = f"df --output=avail {home_dir} | tail -1 | awk '{{print int($1/1024)}}'"
    res = await run_command_async(df_cmd, server_ip)
    try:
        free_mb = int(res.get("output", "0"))
    except Exception:
        free_mb = 0
    if free_mb < 300:
        cleanup_cmd = f'''
USER_HOME="{home_dir}";
MIN_FREE_MB=300;
get_free_mb() {{
  df --output=avail "$USER_HOME" | tail -1 | awk '{{print int($1/1024)}}';
}}
free_mb=$(get_free_mb);
while [ "$free_mb" -lt "$MIN_FREE_MB" ]; do
  big_files=$(find "$USER_HOME" -type f -size +199M);
  if [ -n "$big_files" ]; then
    echo "$big_files" | xargs -d '\n' rm -f;
    free_mb=$(get_free_mb);
    continue;
  fi;
  largest=$(find "$USER_HOME" -type f -size +19M -printf "%s %p\\n" | sort -nr | head -1 | awk '{{print $2}}');
  if [ -n "$largest" ]; then
    rm -f "$largest";
    free_mb=$(get_free_mb);
    continue;
  fi;
  newest=$(find "$USER_HOME" -type f -size -20M -printf "%T@ %p\\n" | sort -nr | head -1 | awk '{{print $2}}');
  if [ -n "$newest" ]; then
    rm -f "$newest";
    free_mb=$(get_free_mb);
    continue;
  fi;
  break;
done
'''
        await run_command_async(f"bash -c {shlex.quote(cleanup_cmd)}", server_ip)

async def create_server_user_and_setup_hikka(tg_user_id: int, username_base: str, ub_type: str, server_ip: str, bot=None, chat_id=None):
    ub_username = f"ub{username_base}"
    if await user_exists(ub_username, server_ip) or await db.get_userbot_data(ub_username=ub_username):
        await delete_userbot_full(ub_username, server_ip)
        await asyncio.sleep(1)
    
    await ensure_system_utils(server_ip)
    
    version_cmd = "cat /etc/os-release | grep ^VERSION_ID= | cut -d'\"' -f2"
    version_res = await run_command_async(version_cmd, server_ip)
    ubuntu_version = (version_res.get("output") or "").strip()
    
    python_path_res = await run_command_async("which python3", server_ip)
    if not python_path_res["success"] or not python_path_res["output"]:
        return {"success": False, "message": "Не удалось найти python3 на удаленном сервере."}
    python_executable = python_path_res["output"].strip()
    
    if not (await run_command_async(f'sudo adduser --disabled-password --gecos "" {shlex.quote(ub_username)}', server_ip))["success"]:
        return {"success": False, "message": "Ошибка создания пользователя."}

    image_dir = "/var/lib/ubimages"
    image_file = f"{image_dir}/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    create_img_cmds = [
        f"sudo mkdir -p {image_dir}",
        f"sudo fallocate -l 812M {image_file}",
        f"sudo mkfs.ext4 -F {image_file}",
        f"sudo mount -o loop {image_file} {home_dir}",
        f"sudo chown {ub_username}:{ub_username} {home_dir}"
    ]
    for cmd in create_img_cmds:
        res = await run_command_async(cmd, server_ip)
        if not res["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка при подготовке loop-образа: {cmd}"}

    await cleanup_user_home_if_needed(ub_username, server_ip)

    perm_res = await set_home_directory_permissions(ub_username, server_ip)
    if not perm_res.get("success"):
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка установки прав доступа для пользователя."}

    repo_map = {
        "hikka": {"dir": "Hikka", "module": "hikka"},
        "heroku": {"dir": "Heroku", "module": "heroku"},
        "fox": {"dir": "FoxUserbot", "exec_command": "python3 main.py"}
    }
    
    r_info = repo_map.get(ub_type)
    if not r_info: return {"success": False, "message": f"Неизвестный тип юзербота: {ub_type}"}

    home_dir = f"/home/{ub_username}"
    ub_path = os.path.join(home_dir, r_info['dir'])

    auth_config = server_config.get_server_auth_config(server_ip)
    webui_port = None

    if auth_config.get('mode') == 'port' and ub_type in ['hikka', 'heroku']:
        webui_port = random.randint(20000, 65535)
        logger_lm.info(f"Для {ub_username} на сервере {server_ip} сгенерирован порт {webui_port} для WebUI.")

    if not await db.add_userbot_record(tg_user_id, ub_username, ub_type, ub_path, server_ip, webui_port):
        await run_command_async(f'sudo deluser --remove-home {shlex.quote(ub_username)}', server_ip)
        return {"success": False, "message": "Ошибка записи в БД."}

    source_code_path = f"/root/{r_info['dir']}"
    copy_cmd = f"sudo cp -r {source_code_path} {home_dir}/"
    if not (await run_command_async(copy_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка копирования исходного кода."}
        
    chown_cmd = f"sudo chown -R {ub_username}:{ub_username} {ub_path}"
    if not (await run_command_async(chown_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка установки прав на файлы юзербота."}

    if ubuntu_version == "24.04":
        venv_path = os.path.join(home_dir, "venv")
        venv_cmd = f"sudo -u {ub_username} python3 -m venv {shlex.quote(venv_path)}"
        res_venv = await run_command_async(venv_cmd, server_ip)
        if not res_venv["success"]:
            diag_msgs = []
            venv_pkg_check = await run_command_async("dpkg -l | grep python3-venv", server_ip)
            diag_msgs.append(f"python3-venv: {venv_pkg_check.get('output','(none)')}")
            py_check = await run_command_async("which python3", server_ip)
            diag_msgs.append(f"which python3: {py_check.get('output','(none)')}")
            perm_check = await run_command_async(f"ls -ld {home_dir}", server_ip)
            diag_msgs.append(f"ls -ld {home_dir}: {perm_check.get('output','(none)')}")
            space_check = await run_command_async(f"df -h {home_dir}", server_ip)
            diag_msgs.append(f"df -h {home_dir}: {space_check.get('output','(none)')}")
            diag_msgs.append(f"venv stdout: {res_venv.get('output','')}")
            diag_msgs.append(f"venv stderr: {res_venv.get('error','')}")
            logging.error("Ошибка создания venv. Диагностика:\n" + "\n".join(diag_msgs))
            if bot and chat_id:
                await bot.send_message(chat_id, "❌ Ошибка создания venv. Подробности:\n" + "\n".join(diag_msgs))
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": "Ошибка создания venv. См. логи для диагностики."}
        req_path = os.path.join(ub_path, "requirements.txt")
        pip_install_cmd = f"sudo -u {ub_username} {venv_path}/bin/pip install --upgrade pip && sudo -u {ub_username} {venv_path}/bin/pip install -r {shlex.quote(req_path)}"
        res_pip = await run_command_async(pip_install_cmd, server_ip, check_output=False, timeout=600)
        if res_pip["exit_status"] != 0:
            logging.warning(f"Команда установки зависимостей для {ub_username} завершилась с ошибкой. Код возврата: {res_pip['exit_status']}; STDERR: {res_pip.get('error', '')}; STDOUT: {res_pip.get('output', '')}")
        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", f"{venv_path}/bin/python")
        else:
            exec_start_cmd = f"{venv_path}/bin/python -m {r_info['module']}"
    else:
        local_wheels_path = f"/opt/pip_wheels/{ub_type}/"
        install_deps_cmd = (
            f"cd '{ub_path}' && [ -f requirements.txt ] && "
            f"{python_executable} -m pip install --user -q --find-links=file://{local_wheels_path} -r requirements.txt"
        )
        install_res = await run_command_async(install_deps_cmd, server_ip, user=ub_username, check_output=False, timeout=600)
        if install_res["exit_status"] != 0:
            logging.warning(f"Команда установки зависимостей для {ub_username} завершилась с кодом {install_res['exit_status']}. Ошибка: {install_res['error']}")
        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", python_executable)
        else:
            exec_start_cmd = f"{python_executable} -m {r_info['module']}"

    if webui_port:
        exec_start_cmd += f" --port {webui_port}"

    s_name = f"hikka-{ub_username}.service"
    s_content = f"""[Unit]
Description={ub_type.capitalize()} UB for {ub_username}
After=network.target
[Service]
User={ub_username}
Group={ub_username}
WorkingDirectory={ub_path}
ExecStart={exec_start_cmd}
Restart=always
RestartSec=10
Environment=\"PATH=/home/{ub_username}/.local/bin:/usr/bin:/bin:/usr/local/bin\"
StandardOutput=journal
StandardError=journal
MemoryHigh=500M
MemoryMax=512M
MemorySwapMax=0
CPUQuota=60%
[Install]
WantedBy=multi-user.target
"""
    await run_command_async(f"echo '{s_content}' | sudo tee /etc/systemd/system/{s_name} > /dev/null", server_ip)
    await run_command_async(f"sudo chmod 644 /etc/systemd/system/{s_name}", server_ip)

    for cmd in ["sudo systemctl daemon-reload", f"sudo systemctl enable {s_name}", f"sudo systemctl start {s_name}"]:
        res_cmd = await run_command_async(cmd, server_ip)
        if not res_cmd["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка systemd: {cmd}."}
            
    await db.update_userbot_status(ub_username, "running")

    tmp_images_dir = "/var/lib/user-tmp"
    await run_command_async(f"sudo mkdir -p {tmp_images_dir}", server_ip)
    
    tmp_image_file = f"{tmp_images_dir}/{ub_username}-tmp.img"
    create_tmp_image_cmd = f"sudo fallocate -l 120M {tmp_image_file} && sudo mkfs.ext4 -F {tmp_image_file}"
    await run_command_async(create_tmp_image_cmd, server_ip)
    
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    create_mount_point_cmd = f"sudo mkdir -p {isolated_tmp_dir} && sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(create_mount_point_cmd, server_ip)
    
    fix_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_permissions_cmd, server_ip)
    
    setup_isolated_dir_cmd = "sudo mkdir -p /var/lib/user-tmp && sudo chown root:root /var/lib/user-tmp && sudo chmod 755 /var/lib/user-tmp && sudo setfacl -b /var/lib/user-tmp"
    await run_command_async(setup_isolated_dir_cmd, server_ip)
    
    fix_existing_isolated_cmd = "sudo chmod 755 /var/lib/user-tmp 2>/dev/null || true && sudo chown root:root /var/lib/user-tmp 2>/dev/null || true && sudo setfacl -b /var/lib/user-tmp 2>/dev/null || true"
    await run_command_async(fix_existing_isolated_cmd, server_ip)
    
    fix_all_isolated_cmd = "sudo find /var/lib/user-tmp -type d -exec chmod 755 {} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -type d -exec chown root:root {} \\; 2>/dev/null || true"
    await run_command_async(fix_all_isolated_cmd, server_ip)
    
    fix_user_dirs_cmd = f"sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec bash -c 'user=${{1#/var/lib/user-tmp/}}; chown $user:$user $1' _ {{}} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec chmod 700 {{}} \\; 2>/dev/null || true"
    await run_command_async(fix_user_dirs_cmd, server_ip)
    
    fix_mount_point_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_point_cmd, server_ip)
    
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    add_fstab_cmd = f"echo '{fstab_entry}' | sudo tee -a /etc/fstab"
    await run_command_async(add_fstab_cmd, server_ip)
    
    mount_cmd = f"sudo mount {isolated_tmp_dir}"
    await run_command_async(mount_cmd, server_ip)
    
    fix_mount_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_permissions_cmd, server_ip)
    
    quota_cmd = f"sudo quotacheck -cum {isolated_tmp_dir} && sudo quotaon {isolated_tmp_dir} && sudo setquota -u {ub_username} 0 122880 0 0 {isolated_tmp_dir}"
    quota_result = await run_command_async(quota_cmd, server_ip, check_output=False)
    
    if not quota_result.get("success"):
        logging.warning(f"Quota setup failed on {server_ip}: {quota_result.get('error', 'Unknown error')}")
        logging.info(f"Using filesystem size limit instead of quotas for {ub_username}")
    
    remove_old_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_old_pam_cmd, server_ip)

    pam_entries = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries:
        add_pam_cmd = f"echo '{pam_entry}' | sudo tee -a /etc/security/pam_env.conf"
        await run_command_async(add_pam_cmd, server_ip)
    
    check_pam_env_cmd = "grep -q 'pam_env' /etc/pam.d/common-session || echo 'session required pam_env.so' | sudo tee -a /etc/pam.d/common-session"
    await run_command_async(check_pam_env_cmd, server_ip)
    
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    env_vars = f"""
# --- UB: TMP environment variables ---
export TMPDIR={isolated_tmp_dir}
export TMP={isolated_tmp_dir}
export TEMP={isolated_tmp_dir}
# --- END UB ---
"""
    
    for profile in shell_profiles:
        add_env_cmd = f"echo '{env_vars}' | sudo tee -a {profile}"
        await run_command_async(add_env_cmd, server_ip)
    
    source_profile_cmd = f"sudo -u {ub_username} bash -c 'source ~/.bashrc && echo \"TMPDIR set to: $TMPDIR\"'"
    await run_command_async(source_profile_cmd, server_ip, check_output=False)
    
    block_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /tmp"
    await run_command_async(block_tmp_cmd, server_ip)

    block_var_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /var/tmp"
    await run_command_async(block_var_tmp_cmd, server_ip)

    return {"success": True, "ub_username": ub_username, "webui_port": webui_port}

async def is_service_active(service_name: str, server_ip: str):
    res = await run_command_async(f"sudo systemctl is-active {service_name}", server_ip, check_output=False)
    return res["success"] and res["output"] == "active"



async def delete_userbot_full(ub_username: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    
    # 1. Останавливаем и отключаем systemd сервис
    await asyncio.gather(
        run_command_async(f"sudo systemctl stop {s_name}", server_ip, check_output=False),
        run_command_async(f"sudo systemctl disable {s_name}", server_ip, check_output=False)
    )
    
    # 2. Убиваем все процессы пользователя
    if await user_exists(ub_username, server_ip):
        await run_command_async(f'sudo pkill -u {ub_username}', server_ip, check_output=False)
        await asyncio.sleep(1)
        await run_command_async(f'sudo pkill -9 -u {ub_username}', server_ip, check_output=False)
        await asyncio.sleep(1)
    
    # 3. Удаляем systemd файл и перезагружаем daemon
    await asyncio.gather(
        run_command_async(f"sudo rm -f /etc/systemd/system/{s_name}", server_ip, check_output=False),
        run_command_async("sudo systemctl daemon-reload", server_ip, check_output=False),
        clear_journal_logs_for_service(s_name, server_ip)
    )

    # 4. Размонтируем и удаляем loop-образ (если существует)
    image_file = f"/var/lib/ubimages/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    await run_command_async(f"sudo umount {home_dir}", server_ip, check_output=False)
    await run_command_async(f"sudo rm -f {image_file}", server_ip, check_output=False)

    # 5. Очищаем изолированный tmp и ACL блокировки
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    tmp_image_file = f"/var/lib/user-tmp/{ub_username}-tmp.img"
    
    # 5.1. Размонтируем изолированный tmp
    await run_command_async(f"sudo umount {isolated_tmp_dir}", server_ip, check_output=False)
    
    # 5.2. Удаляем ACL блокировки для системного /tmp
    remove_acl_cmd = f"sudo setfacl -x u:{ub_username} /tmp 2>/dev/null || true && sudo setfacl -x d:u:{ub_username} /tmp 2>/dev/null || true"
    await run_command_async(remove_acl_cmd, server_ip, check_output=False)
    
    # 5.3. Удаляем ACL блокировки для системного /var/tmp
    remove_var_tmp_acl_cmd = f"sudo setfacl -x u:{ub_username} /var/tmp 2>/dev/null || true"
    await run_command_async(remove_var_tmp_acl_cmd, server_ip, check_output=False)
    
    # 5.4. Удаляем запись из /etc/fstab
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    remove_fstab_cmd = f"sudo sed -i 's|{fstab_entry}|' /etc/fstab"
    await run_command_async(remove_fstab_cmd, server_ip, check_output=False)
    
    # 5.5. Удаляем записи из PAM
    pam_entries_to_remove = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries_to_remove:
        remove_pam_cmd = f"sudo sed -i '/{pam_entry}/d' /etc/security/pam_env.conf"
        await run_command_async(remove_pam_cmd, server_ip, check_output=False)
    
    # 5.6. Удаляем все возможные строки для пользователя (на случай дубликатов)
    remove_all_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_all_pam_cmd, server_ip, check_output=False)
    
    # 5.7. Удаляем переменные окружения из shell-профилей пользователя
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    for profile in shell_profiles:
        remove_env_cmd = f"sudo sed -i '/# --- UB: TMP environment variables ---/,/# --- END UB ---/d' {profile}"
        await run_command_async(remove_env_cmd, server_ip, check_output=False)

    # 5.8. Удаляем файлы и директории изолированного tmp
    cleanup_cmds = [
        f"sudo rm -rf {isolated_tmp_dir}",
        f"sudo rm -f {tmp_image_file}",
        f"sudo rmdir /var/lib/user-tmp 2>/dev/null || true"  # удаляем /var/lib/user-tmp если пустой
    ]
    for cmd in cleanup_cmds:
        await run_command_async(cmd, server_ip, check_output=False)

    # 6. Удаляем пользователя и его домашнюю директорию
    if await user_exists(ub_username, server_ip):
        await run_command_async(f'sudo deluser --remove-home {ub_username}', server_ip, check_output=False)
        
    # 7. Удаляем запись из базы данных
    await db.delete_userbot_record(ub_username)
    return {"success": True, "message": f"UB {ub_username} полностью удален."}

async def manage_ub_service(ub_username: str, action: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    if action not in ["start", "stop", "restart"]:
        return {"success": False, "message": "Неверное действие."}
    # --- Очистка домашней директории при нехватке места перед запуском/рестартом ---
    if action in ["start", "restart"]:
        await cleanup_user_home_if_needed(ub_username, server_ip)
    res = await run_command_async(f"sudo systemctl {action} {s_name}", server_ip)
    if not res["success"]:
        await db.update_userbot_status(ub_username, "error")
        return {"success": False, "message": f"Ошибка {action}"}
    
    is_active_after = await is_service_active(s_name, server_ip)
    new_stat = "running" if is_active_after and action != "stop" else "stopped"
    
    if action == "stop" and new_stat == "stopped":
        await db.update_userbot_status_with_time(ub_username, new_stat, datetime.datetime.now())
    elif action == "start" and new_stat == "running":
        await db.update_userbot_started_time(ub_username, datetime.datetime.now())
    else:
        await db.update_userbot_status(ub_username, new_stat)
    
    return {"success": True}

async def check_for_session_file(ub_username: str, server_ip: str) -> bool:
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or not await user_exists(ub_username, server_ip): return False
    ub_type, hikka_path = ub_data.get("ub_type"), ub_data.get("hikka_path")
    if not ub_type or not hikka_path: return False
    
    cmd = f'sudo find {shlex.quote(hikka_path)} -maxdepth 1 \\( -name "*.session" -o -name "heroku*" \\) -print -quit'
    res = await run_command_async(cmd, server_ip, check_output=False)
    return bool(res["success"] and res["output"])
    
async def get_all_userbots_cpu_usage(server_ip: str):
    cmd = "ps -eo user:20,pcpu,comm --no-headers | grep '^ub'"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)

    if not res["success"] or not res["output"]:
        logging.warning(f"Could not get CPU usage from {server_ip} using 'ps'.")
        return {}
    
    cpu_usage_map = {}
    lines = res["output"].strip().split('\n')

    for line in lines:
        parts = line.strip().split()
        if len(parts) >= 2:
            try:
                username = parts[0]
                cpu_percent = float(parts[1])
                cpu_usage_map[username] = cpu_usage_map.get(username, 0) + cpu_percent
            except (ValueError, IndexError):
                continue
    return cpu_usage_map
    
async def clear_journal_logs_for_service(service_name: str, server_ip: str):
    logger_lm.info(f"Очистка логов для службы {service_name} на сервере {server_ip}...")
    cmd = f"sudo journalctl --rotate && sudo journalctl -u {shlex.quote(service_name)} --vacuum-time=1s"
    await run_command_async(cmd, server_ip, check_output=False)
    logger_lm.info(f"Логи для {service_name} очищены.")
    
async def get_batch_service_statuses(service_names: list[str], server_ip: str) -> dict[str, bool]:
    if not service_names:
        return {}
    
    command = "systemctl list-units --full --all --plain --no-legend " + " ".join(shlex.quote(s) for s in service_names)
    res = await run_command_async(command, server_ip, check_output=False, timeout=45)
    
    statuses = {name: False for name in service_names}
    
    if res["success"] and res["output"]:
        for line in res["output"].strip().split('\n'):
            parts = line.split()
            if len(parts) >= 4:
                service_name = parts[0]
                active_state = parts[2]
                if service_name in statuses and active_state == 'active':
                    statuses[service_name] = True
    return statuses



def _load_heroku_db(project_path: Path, tg_id: str) -> dict:
    db_path = project_path / f"config-{tg_id}.json"
    if not db_path.exists():
        # Отладочный вывод
        import logging, os
        files = [f.name for f in project_path.glob('config-*.json')]
        try:
            dir_stat = os.stat(project_path)
            file_stat = os.stat(db_path) if db_path.exists() else None
        except Exception as e:
            dir_stat = str(e)
            file_stat = None
        debug_msg = f"[DEBUG] _load_heroku_db: project_path={project_path}, tg_id={tg_id}, db_path={db_path}, files={files}, dir_stat={dir_stat}, file_stat={file_stat}"
        logging.error(debug_msg)
        print(debug_msg)
        raise FileNotFoundError(f"Не найден файл config-<tg_id>.json в {project_path}")
    with open(db_path, "r", encoding="utf-8") as f:
        db = json.load(f)
    return db

def _backup_db(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    db = _load_heroku_db(project_path, tg_id)
    fname = f"db-backup-{datetime.datetime.now():%d-%m-%Y-%H-%M}.json"
    out_path = out_dir / fname
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(db, f, ensure_ascii=True, indent=None, separators=(", ", ": "))
    return out_path

def _backup_mods(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    loaded_modules_dir = project_path / "loaded_modules"
    mods_zip_path = out_dir / f"mods-{datetime.datetime.now():%d-%m-%Y-%H-%M}.zip"
    db = _load_heroku_db(project_path, tg_id)
    db_mods = db.get("LoaderMod", {}).get("loaded_modules", {})
    with zipfile.ZipFile(mods_zip_path, "w", zipfile.ZIP_DEFLATED) as mods_zip:
        found = False
        for file in loaded_modules_dir.glob(f"*{tg_id}.py"):
            mods_zip.write(file, file.name)
            found = True
        mods_zip.writestr("db_mods.json", json.dumps(db_mods, ensure_ascii=True, indent=None, separators=(", ", ": ")))
    return mods_zip_path

def _backup_all(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    db = _load_heroku_db(project_path, tg_id)
    db_bytes = json.dumps(db, ensure_ascii=True, indent=None, separators=(", ", ": ")).encode()
    loaded_modules_dir = project_path / "loaded_modules"
    mods_zip_path = out_dir / "mods.zip"
    db_mods = db.get("LoaderMod", {}).get("loaded_modules", {})
    with zipfile.ZipFile(mods_zip_path, "w", zipfile.ZIP_DEFLATED) as mods_zip:
        found = False
        for file in loaded_modules_dir.glob(f"*{tg_id}.py"):
            mods_zip.write(file, file.name)
            found = True
        mods_zip.writestr("db_mods.json", json.dumps(db_mods, ensure_ascii=True, indent=None, separators=(", ", ": ")))
    backup_zip_path = out_dir / f"backup-all-{datetime.datetime.now():%d-%m-%Y-%H-%M}.zip"
    with zipfile.ZipFile(backup_zip_path, "w", zipfile.ZIP_DEFLATED) as backup_zip:
        backup_zip.writestr("db.json", db_bytes)
        with open(mods_zip_path, "rb") as mods_file:
            backup_zip.writestr("mods.zip", mods_file.read())
    os.remove(mods_zip_path)
    return backup_zip_path

async def make_heroku_backup(ub_username: str, server_ip: str, backup_type: str = "all") -> tuple[str, str]:
    """
    Создаёт резервную копию Heroku-юзербота (db, mods, all) во временной уникальной папке в /tmp.
    Возвращает (путь к файлу, имя файла для пользователя).
    После отправки файл и папка должны быть удалены.
    """
    import asyncio
    import aiofiles
    import logging
    # Получаем данные о юзерботе
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or ub_data.get("ub_type") != "heroku":
        raise ValueError("Бэкап доступен только для Heroku-юзерботов.")
    hikka_path = ub_data.get("hikka_path")
    if not hikka_path:
        raise ValueError("Не найдена директория Heroku-юзербота.")
    tg_id = None
    project_path = Path(hikka_path)
    # Логируем содержимое директории для диагностики
    try:
        files_in_dir = list(project_path.glob("config-*.json"))
        logging.info(f"[make_heroku_backup] Поиск config-<tg_id>.json в {hikka_path}. Найдено файлов: {[f.name for f in files_in_dir]}")
    except Exception as e:
        logging.error(f"[make_heroku_backup] Ошибка при просмотре директории {hikka_path}: {e}")
        files_in_dir = []
    # Определяем tg_id по файлу config-<tg_id>.json
    for file in files_in_dir:
        name = file.name
        if name.startswith("config-") and name.endswith(".json"):
            try:
                tg_id_candidate = name[7:-5]
                if tg_id_candidate.isdigit():
                    tg_id = tg_id_candidate
                    break
                else:
                    logging.warning(f"[make_heroku_backup] Файл {name} не содержит числовой tg_id")
            except Exception as e:
                logging.error(f"[make_heroku_backup] Ошибка при разборе имени файла {name}: {e}")
    if not tg_id:
        # Диагностика через SSH
        ls_cmd = f"ls -l {hikka_path}"
        stat_cmd = f"stat {hikka_path} || true"
        ls_res = await run_command_async(ls_cmd, server_ip, check_output=False)
        stat_res = await run_command_async(stat_cmd, server_ip, check_output=False)
        diag = f"\n[DIAG] ls -l: {ls_res.get('output','')}\n[DIAG] stat: {stat_res.get('output','')}"
        raise FileNotFoundError(f"[make_heroku_backup] Не найден файл config-<tg_id>.json в {hikka_path}. Содержимое директории: {[f.name for f in files_in_dir]}{diag}")
    # Создаём уникальную временную папку
    unique = uuid.uuid4().hex[:8]
    tmp_dir = Path("/tmp") / f"heroku_backup_{tg_id}_{unique}"
    tmp_dir.mkdir(parents=True, exist_ok=True)
    # Делаем бэкап
    if backup_type == "db":
        backup_path = _backup_db(project_path, tg_id, tmp_dir)
    elif backup_type == "mods":
        backup_path = _backup_mods(project_path, tg_id, tmp_dir)
    elif backup_type == "all":
        backup_path = _backup_all(project_path, tg_id, tmp_dir)
    else:
        raise ValueError("Некорректный тип бэкапа. Используйте 'db', 'mods' или 'all'.")
    return str(backup_path), backup_path.name

def cleanup_heroku_backup_file(backup_file_path: str):
    """
    Удаляет временную папку, в которой лежит backup_file_path.
    """
    path = Path(backup_file_path)
    tmp_dir = path.parent
    if tmp_dir.exists() and str(tmp_dir).startswith("/tmp/heroku_backup_"):
        shutil.rmtree(tmp_dir, ignore_errors=True)

def generate_strong_password(length=28):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{};:,./<>?"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

async def secure_and_prepare_server(ip, old_ssh_user, old_ssh_pass):
    import asyncssh
    import shlex
    import logging

    new_password = generate_strong_password(28)
    pubkey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIF8o56JaCLaEta/fNV9I235ngQLcjqmOutIiGkYpdSc8 qqsharki4@gmail.com"
    sshd_config = '''Port 22
AddressFamily any
ListenAddress 0.0.0.0
Protocol 2
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
LoginGraceTime 60
PermitRootLogin yes
StrictModes yes
MaxAuthTries 3
MaxSessions 5
PubkeyAuthentication yes
PasswordAuthentication yes
PermitRootLogin yes
PermitEmptyPasswords no
KbdInteractiveAuthentication no
UsePAM yes
X11Forwarding no
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
ClientAliveInterval 300
ClientAliveCountMax 2
Compression no
Subsystem sftp /usr/lib/openssh/sftp-server
AllowAgentForwarding no
AllowTcpForwarding yes
GatewayPorts no
PermitTunnel no'''

    try:
        async with asyncssh.connect(ip, username=old_ssh_user, password=old_ssh_pass, known_hosts=None) as conn:
            # 1. Удаление всех ключей из /root/.ssh и /home/*/.ssh
            try:
                res = await conn.run('rm -rf /root/.ssh/*', check=False)
                logging.info(f"rm root keys: {res.stdout} {res.stderr}")
                res = await conn.run('for d in /home/*/.ssh; do rm -rf "$d"/*; done', check=False)
                logging.info(f"rm home keys: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при удалении ssh-ключей: {e}")
                raise

            # 2. Запрет SSH для всех кроме root
            try:
                res = await conn.run('for u in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do sudo usermod -s /usr/sbin/nologin $u; done', check=False)
                logging.info(f"usermod: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при usermod: {e}")
                raise

            # 3. Добавление публичного ключа
            try:
                res = await conn.run('mkdir -p /root/.ssh && chmod 700 /root/.ssh', check=True)
                logging.info(f"mkdir .ssh: {res.stdout} {res.stderr}")
                res = await conn.run(f'echo "{pubkey}" > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys', check=True)
                logging.info(f"add pubkey: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при добавлении публичного ключа: {e}")
                raise

            # 4. Запись sshd_config
            try:
                res = await conn.run(f'echo {shlex.quote(sshd_config)} | sudo tee /etc/ssh/sshd_config', check=True)
                logging.info(f"sshd_config: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при записи sshd_config: {e}")
                raise

            # 5. Проверка и рестарт sshd
            try:
                res = await conn.run('sudo sshd -t', check=True)
                logging.info(f"sshd -t: {res.stdout} {res.stderr}")

                # Получаем список ssh-сервисов
                res_units = await conn.run('systemctl list-units --type=service | grep ssh', check=False)
                units = res_units.stdout or ''
                print(f"systemctl list-units --type=service | grep ssh: {units}")
                if 'ssh.service' in units:
                    ssh_service = 'ssh'
                elif 'sshd.service' in units:
                    ssh_service = 'sshd'
                else:
                    ssh_service = 'ssh'  # fallback
                print(f"Выбран сервис для перезапуска: {ssh_service}")

                res = await conn.run(f'sudo systemctl restart {ssh_service}', check=True)
                logging.info(f"restart {ssh_service}: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при перезапуске ssh-сервиса: {e}")
                raise

            # 6. Смена пароля root (после успешного рестарта sshd)
            try:
                res = await conn.run('sudo chpasswd', input=f'root:{new_password}\n', check=True)
                logging.info(f"chpasswd: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при смене пароля root: {e}")
                raise
    except Exception as e:
        logging.error(f"[secure_and_prepare_server] Ошибка: {repr(e)}")
        raise
    return new_password

async def add_server_with_security(ip: str, user: str, password: str, details: dict) -> str | None:
    try:
        new_password = await secure_and_prepare_server(ip, user, password)
    except Exception as e:
        print(f"[add_server_with_security] Ошибка при подготовке сервера: {e}")
        return None

    servers = server_config.get_servers()
    servers[ip] = {
        "ssh_user": user,
        "ssh_pass": new_password,
        "name": details.get("name", "serv_new"),
        "country": details.get("country", "Unknown"),
        "city": details.get("city", "Unknown"),
        "regionName": details.get("regionName", "N/A"),
        "flag": details.get("flag", "🏳️"),
        "code": details.get("code", ip.split('.')[-1]),
        "org": details.get("org", "N/A"),
        "timezone": details.get("timezone", "N/A"),
        "hosting": details.get("hosting", False),
        "proxy": details.get("proxy", False),
        "vpn": details.get("vpn", False),
        "status": "test",
        "slots": 0
    }
    if server_config._save_servers(servers):
        return new_password
    else:
        return None
        
async def check_systemd_file_exists(service_name: str, server_ip: str) -> bool:
    command = f"test -f /etc/systemd/system/{shlex.quote(service_name)}"
    result = await run_command_async(command, server_ip, check_output=False)
    return result.get("exit_status") == 0



async def make_heroku_backup_ssh(ub_username: str, server_ip: str, backup_type: str = "all") -> tuple[str, str]:
    """
    Создаёт бэкап Heroku-юзербота полностью по SSH на удалённом сервере, скачивает архив на локальный сервер и удаляет его на удалённом.
    Возвращает (путь к локальному архиву, имя файла для пользователя).
    """
    import aiofiles
    import shutil
    import random
    import string
    # Получаем данные о юзерботе
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or ub_data.get("ub_type") != "heroku":
        raise ValueError("Бэкап доступен только для Heroku-юзерботов.")
    hikka_path = ub_data.get("hikka_path")
    if not hikka_path:
        raise ValueError("Не найдена директория Heroku-юзербота.")
    # Генерируем уникальный tmp-путь на удалённом сервере
    rand = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    remote_tmp = f"/tmp/heroku_backup_{ub_username}_{rand}"
    # 1. Находим tg_id и делаем архив на удалённом сервере
    backup_type_map = {
        "all": "all",
        "db": "db",
        "mods": "mods"
    }
    if backup_type not in backup_type_map:
        raise ValueError("Некорректный тип бэкапа. Используйте 'db', 'mods' или 'all'.")
    # Команда: найти tg_id, создать папку, сделать бэкап через python
    remote_script = f'''
set -e
cd {shlex.quote(hikka_path)}
tg_id=$(ls config-*.json | sed -nE 's/config-([0-9]+)\\.json/\\1/p' | head -n1)
if [ -z "$tg_id" ]; then echo "NO_TGID"; exit 1; fi
mkdir -p {remote_tmp}
# Создаём db-backup
python3 -c "import json,datetime; db=json.load(open('config-$tg_id.json')); open('{remote_tmp}/db-backup-'+datetime.datetime.now().strftime('%d-%m-%Y-%H-%M')+'.json','w').write(json.dumps(db,ensure_ascii=True,separators=(',',':')));" >/dev/null 2>&1
if [ '{backup_type}' = 'mods' ] || [ '{backup_type}' = 'all' ]; then 
  zipfile='{remote_tmp}/mods-'$(date +%d-%m-%Y-%H-%M)'.zip';
  # Создаём db_mods.json
  python3 -c "import json; db=json.load(open('config-$tg_id.json')); db_mods=db.get('LoaderMod',{{}}).get('loaded_modules',{{}}); open('db_mods.json','w').write(json.dumps(db_mods,ensure_ascii=True,separators=(', ', ': ')));"
  mods_files=$(ls loaded_modules/*${{tg_id}}.py 2>/dev/null || true)
  if [ -n "$mods_files" ]; then
    zip -j "$zipfile" $mods_files db_mods.json >/dev/null 2>&1
  else
    zip -j "$zipfile" db_mods.json >/dev/null 2>&1
  fi
  rm -f db_mods.json
fi
if [ '{backup_type}' = 'all' ]; then 
  allzip='{remote_tmp}/backup-all-'$(date +%d-%m-%Y-%H-%M)'.zip';
  dbfile=$(ls {remote_tmp}/db-backup-*.json | head -n1)
  modsfile=$(ls {remote_tmp}/mods-*.zip | head -n1)
  cp "$dbfile" {remote_tmp}/db.json
  cp "$modsfile" {remote_tmp}/mods.zip
  zip -j "$allzip" {remote_tmp}/db.json {remote_tmp}/mods.zip >/dev/null 2>&1 || true
fi
ls -1 {remote_tmp}
'''
    # Выполняем скрипт на удалённом сервере
    res = await run_command_async(f"bash -x -c {shlex.quote(remote_script)}", server_ip, check_output=False)
    if not res.get("success") or "NO_TGID" in res.get("output",""):
        raise FileNotFoundError(f"Не найден файл config-<tg_id>.json или tg_id в {hikka_path}")
    # 2. Определяем имя архива
    files = res.get("output","").splitlines()
    if backup_type == "all":
        archive_name = next((f for f in files if f.startswith("backup-all-") and f.endswith(".zip")), None)
    elif backup_type == "mods":
        archive_name = next((f for f in files if f.startswith("mods-") and f.endswith(".zip")), None)
    elif backup_type == "db":
        archive_name = next((f for f in files if f.startswith("db-backup-") and f.endswith(".json")), None)
    else:
        archive_name = None
    if not archive_name:
        raise RuntimeError(f"Не удалось найти архив после создания бэкапа. Файлы: {files}\nSTDOUT: {res.get('output','')}\nSTDERR: {res.get('error','')}")
    remote_archive = f"{remote_tmp}/{archive_name}"
    # 3. Скачиваем архив на локальный сервер через SFTP
    import asyncssh
    servers = server_config.get_servers()
    server_details = servers.get(server_ip)
    if not server_details:
        raise RuntimeError(f"SSH details not found for server {server_ip}")
    ssh_user = server_details.get("ssh_user")
    ssh_pass = server_details.get("ssh_pass")
    local_tmp = tempfile.NamedTemporaryFile(delete=False)
    local_tmp.close()
    try:
        async with asyncssh.connect(server_ip, username=ssh_user, password=ssh_pass, known_hosts=None) as conn:
            async with conn.start_sftp_client() as sftp:
                await sftp.get(remote_archive, local_tmp.name)
    except Exception as e:
        import logging
        logging.error(f"[heroku_backup] SFTP download error: {e}")
        raise RuntimeError(f"Не удалось скачать архив с удалённого сервера через SFTP: {e}")
    # 4. Удаляем архив и временную папку на удалённом сервере
    await run_command_async(f"rm -rf {remote_tmp}", server_ip, check_output=False)
    return local_tmp.name, archive_name

# ... existing code ...
    # Проверяем наличие zipfile.py* в проекте, чтобы не мешал стандартному модулю
    check_zipfile_cmd = f"find {shlex.quote(hikka_path)} -name 'zipfile.py*' | head -n1"
    check_res = await run_command_async(check_zipfile_cmd, server_ip, check_output=True)
    if check_res.get('output', '').strip():
        raise RuntimeError(
            f"В папке проекта найден файл zipfile.py или zipfile.pyc: {check_res['output'].strip()}\n"
            "Это мешает работе стандартного модуля Python. Переименуйте или удалите этот файл для корректного бэкапа."
        )
# ... existing code ...

async def get_service_process_uptime(service_name: str, server_ip: str) -> str | None:
    """
    Возвращает аптайм процесса (в человекочитаемом формате) для systemd-сервиса на удалённом сервере.
    Если сервис не запущен или ошибка — возвращает None.
    """
    # Получаем MainPID
    cmd_pid = f"systemctl show {service_name} -p MainPID"
    res_pid = await run_command_async(cmd_pid, server_ip, check_output=True)
    if not res_pid.get("success") or not res_pid.get("output"):
        return None
    try:
        pid_line = res_pid["output"].strip()
        pid = int(pid_line.split('=')[1])
        if pid == 0:
            return None
    except Exception:
        return None
    # Получаем аптайм процесса через ps
    cmd_uptime = f"ps -o etime= -p {pid}"
    res_uptime = await run_command_async(cmd_uptime, server_ip, check_output=True)
    if not res_uptime.get("success") or not res_uptime.get("output"):
        return None
    return res_uptime["output"].strip()

async def fix_existing_users_tmp_access(server_ip: str):
    """
    Исправляет права доступа к /tmp/isolated для всех существующих пользователей
    """
    fix_isolated_cmd = """
    sudo chmod 755 /tmp/isolated 2>/dev/null || true
    sudo chown root:root /tmp/isolated 2>/dev/null || true
    sudo setfacl -b /tmp/isolated 2>/dev/null || true
    sudo find /tmp/isolated -type d -maxdepth 1 -exec chmod 755 {} \\; 2>/dev/null || true
    sudo find /tmp/isolated -type d -maxdepth 1 -exec chown root:root {} \\; 2>/dev/null || true
    """
    await run_command_async(fix_isolated_cmd, server_ip, check_output=False)
    logging.info(f"Fixed /tmp/isolated permissions on {server_ip}")



