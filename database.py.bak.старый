import sqlite3
import logging
from typing import Dict, Any, List, Optional
import datetime

logger = logging.getLogger(__name__)
DB_NAME = "userbots.db"

def init_db():
    try:
        with sqlite3.connect(DB_NAME) as conn:
            cursor = conn.cursor()

            desired_user_columns = {
                "tg_user_id": "INTEGER PRIMARY KEY", "username": "TEXT",
                "full_name": "TEXT", "registered_at": "DATETIME",
                "agreement_accepted": "INTEGER NOT NULL DEFAULT 0",
                "is_banned": "INTEGER NOT NULL DEFAULT 0", "note": "TEXT"
            }
            
            cursor.execute("CREATE TABLE IF NOT EXISTS users (tg_user_id INTEGER PRIMARY KEY)")
            
            cursor.execute("PRAGMA table_info(users)")
            existing_columns = [column[1] for column in cursor.fetchall()]

            for col_name, col_type in desired_user_columns.items():
                if col_name not in existing_columns:
                    cursor.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
                    logger.info(f"Добавлен столбец '{col_name}' в таблицу 'users'.")
            
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS userbots (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tg_user_id INTEGER NOT NULL,
                    ub_username TEXT NOT NULL UNIQUE,
                    server_ip TEXT NOT NULL,
                    ub_type TEXT,
                    hikka_path TEXT,
                    status TEXT DEFAULT 'stopped',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    blocked INTEGER NOT NULL DEFAULT 0,
                    warning_sent_at DATETIME,
                    is_warned INTEGER NOT NULL DEFAULT 0,
                    FOREIGN KEY (tg_user_id) REFERENCES users (tg_user_id) ON DELETE CASCADE
                )
            """)
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_userbots_tg_user_id ON userbots (tg_user_id);")

            cursor.execute("PRAGMA table_info(userbots)")
            existing_ub_columns = [column[1] for column in cursor.fetchall()]

            if 'warning_sent_at' not in existing_ub_columns:
                cursor.execute("ALTER TABLE userbots ADD COLUMN warning_sent_at DATETIME")
                logger.info("Добавлен столбец 'warning_sent_at' в таблицу 'userbots'.")

            if 'is_warned' not in existing_ub_columns:
                cursor.execute("ALTER TABLE userbots ADD COLUMN is_warned INTEGER NOT NULL DEFAULT 0")
                logger.info("Добавлен столбец 'is_warned' в таблицу 'userbots'.")

            cursor.execute("""
                CREATE TABLE IF NOT EXISTS commits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    commit_id TEXT NOT NULL UNIQUE,
                    admin_id INTEGER NOT NULL,
                    admin_name TEXT NOT NULL,
                    admin_username TEXT,
                    commit_text TEXT NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_commits_created_at ON commits (created_at);")

            cursor.execute("""
                CREATE TABLE IF NOT EXISTS commit_votes (
                    commit_id TEXT NOT NULL,
                    user_id INTEGER NOT NULL,
                    vote_type INTEGER NOT NULL,
                    PRIMARY KEY (commit_id, user_id)
                )
            """)

            conn.commit()
            logger.info("Инициализация и проверка схемы базы данных завершены.")

    except sqlite3.Error as e:
        logger.error(f"Ошибка инициализации БД: {e}", exc_info=True)
        raise

def _get_connection() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_NAME, timeout=10)
    conn.row_factory = sqlite3.Row
    return conn

def set_user_note(user_id: int, note: Optional[str]) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute("UPDATE users SET note = ? WHERE tg_user_id = ?", (note, user_id))
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка установки заметки для {user_id}: {e}")
        return False

def set_user_ban_status(user_id: int, is_banned: bool) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute("UPDATE users SET is_banned = ? WHERE tg_user_id = ?", (1 if is_banned else 0, user_id))
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка установки статуса бана для {user_id}: {e}")
        return False

def is_user_banned(user_id: int) -> bool:
    user_data = get_user_data(user_id)
    return bool(user_data and user_data.get("is_banned", 0))

def get_user_by_username_or_id(identifier: str) -> Optional[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            clean_identifier = identifier.lstrip('@')

            if clean_identifier.isdigit():
                cursor.execute("SELECT * FROM users WHERE tg_user_id = ?", (int(clean_identifier),))
            else:
                cursor.execute("SELECT * FROM users WHERE username = ?", (clean_identifier,))
            
            user_data = cursor.fetchone()
            return dict(user_data) if user_data else None
    except (sqlite3.Error, ValueError) as e:
        logger.error(f"Ошибка поиска пользователя по '{identifier}': {e}", exc_info=True)
        return None

def register_or_update_user(tg_user_id: int, username: Optional[str], full_name: Optional[str]) -> bool:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT 1 FROM users WHERE tg_user_id = ?", (tg_user_id,))
            exists = cursor.fetchone() is not None
            
            if not exists:
                cursor.execute(
                    "INSERT INTO users (tg_user_id, username, full_name, registered_at, agreement_accepted) VALUES (?, ?, ?, CURRENT_TIMESTAMP, 0)",
                    (tg_user_id, username, full_name)
                )
                logger.info(f"Зарегистрирован новый пользователь: {tg_user_id}")
            else:
                cursor.execute(
                    "UPDATE users SET username = ?, full_name = ? WHERE tg_user_id = ?",
                    (username, full_name, tg_user_id)
                )
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка БД при работе с пользователем {tg_user_id}: {e}", exc_info=True)
        return False

def set_user_agreement_accepted(tg_user_id: int) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute("UPDATE users SET agreement_accepted = 1 WHERE tg_user_id = ?", (tg_user_id,))
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка при установке согласия для {tg_user_id}: {e}")
        return False

def has_user_accepted_agreement(tg_user_id: int) -> bool:
    user_data = get_user_data(tg_user_id)
    return bool(user_data and user_data.get("agreement_accepted"))

def get_user_data(tg_user_id: int) -> Optional[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE tg_user_id = ?", (tg_user_id,))
            result = cursor.fetchone()
            return dict(result) if result else None
    except sqlite3.Error as e:
        logger.error(f"SQL ошибка в get_user_data: {e}", exc_info=True)
        return None

def add_userbot_record(tg_user_id: int, ub_username: str, ub_type: str, hikka_path: str, server_ip: str) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute(
                "INSERT INTO userbots (tg_user_id, ub_username, ub_type, hikka_path, server_ip, status, blocked) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (tg_user_id, ub_username, ub_type, hikka_path, server_ip, 'installing', 0)
            )
            conn.commit()
            return True
    except sqlite3.IntegrityError:
        logger.warning(f"Попытка добавить существующего UB: {ub_username}", exc_info=True)
        return False
    except sqlite3.Error as e:
        logger.error(f"Ошибка добавления UB {ub_username}: {e}", exc_info=True)
        return False

def update_userbot_status(ub_username: str, status: str) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute("UPDATE userbots SET status = ? WHERE ub_username = ?", (status, ub_username))
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка обновления статуса UB {ub_username}: {e}", exc_info=True)
        return False

def block_userbot(ub_username: str, blocked_status: bool) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute("UPDATE userbots SET blocked = ? WHERE ub_username = ?", (1 if blocked_status else 0, ub_username))
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка блокировки {ub_username}: {e}")
        return False

def get_userbot_data(ub_username: str) -> Optional[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM userbots WHERE ub_username = ?", (ub_username,))
            data = cursor.fetchone()
            return dict(data) if data else None
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения данных UB: {e}", exc_info=True)
        return None

def get_userbots_by_tg_id(tg_user_id: int) -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM userbots WHERE tg_user_id = ?", (tg_user_id,))
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения списка UB для {tg_user_id}: {e}", exc_info=True)
        return []

def get_userbot_by_tg_id_and_username(tg_user_id: int, ub_username: str) -> Optional[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM userbots WHERE tg_user_id = ? AND ub_username = ?", (tg_user_id, ub_username))
            data = cursor.fetchone()
            return dict(data) if data else None
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения UB {ub_username} для пользователя {tg_user_id}: {e}", exc_info=True)
        return None

def get_userbots_by_server_ip(server_ip: str) -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM userbots WHERE server_ip = ?", (server_ip,))
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения списка UB для сервера {server_ip}: {e}", exc_info=True)
        return []

def get_all_userbots_full_info() -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM userbots")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения полной информации о юзерботах: {e}", exc_info=True)
        return []

def delete_userbot_record(ub_username: str) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute("DELETE FROM userbots WHERE ub_username = ?", (ub_username,))
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка удаления UB {ub_username}: {e}", exc_info=True)
        return False

def get_all_bot_users() -> List[int]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tg_user_id FROM users")
            rows = cursor.fetchall()
            return [row['tg_user_id'] for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения всех пользователей: {e}", exc_info=True)
        return []

def get_all_users_with_reg_date() -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT tg_user_id, registered_at FROM users")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения всех пользователей с датой регистрации: {e}", exc_info=True)
        return []

def get_userbot_owners_count() -> int:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(DISTINCT tg_user_id) FROM userbots")
            result = cursor.fetchone()
            return result[0] if result else 0
    except sqlite3.Error:
        return 0

def get_all_registered_users() -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE agreement_accepted = 1")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения зарегистрированных пользователей: {e}", exc_info=True)
        return []

def get_all_unregistered_users() -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE agreement_accepted = 0 OR agreement_accepted IS NULL")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения незарегистрированных пользователей: {e}", exc_info=True)
        return []

def transfer_userbot(ub_username: str, new_owner_id: int) -> bool:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE userbots SET tg_user_id = ? WHERE ub_username = ?", (new_owner_id, ub_username))
            conn.commit()
            return cursor.rowcount > 0
    except sqlite3.Error as e:
        logger.error(f"Ошибка переноса юзербота {ub_username} новому владельцу {new_owner_id}: {e}", exc_info=True)
        return False
        
def add_commit(commit_id: str, admin_id: int, admin_name: str, admin_username: Optional[str], commit_text: str) -> bool:
    try:
        with _get_connection() as conn:
            conn.execute(
                "INSERT INTO commits (commit_id, admin_id, admin_name, admin_username, commit_text, created_at) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)",
                (commit_id, admin_id, admin_name, admin_username, commit_text)
            )
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка добавления коммита {commit_id}: {e}", exc_info=True)
        return False

def get_all_commits() -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM commits ORDER BY created_at DESC")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения всех коммитов: {e}", exc_info=True)
        return []

def get_commit_by_id(commit_id: str) -> Optional[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM commits WHERE commit_id = ?", (commit_id,))
            data = cursor.fetchone()
            return dict(data) if data else None
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения коммита {commit_id}: {e}", exc_info=True)
        return None
       
def set_vote(commit_id: str, user_id: int, vote_type: int) -> bool:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT vote_type FROM commit_votes WHERE commit_id = ? AND user_id = ?", (commit_id, user_id))
            current_vote = cursor.fetchone()

            if current_vote and current_vote['vote_type'] == vote_type:
                cursor.execute("DELETE FROM commit_votes WHERE commit_id = ? AND user_id = ?", (commit_id, user_id))
            else:
                cursor.execute(
                    "INSERT OR REPLACE INTO commit_votes (commit_id, user_id, vote_type) VALUES (?, ?, ?)",
                    (commit_id, user_id, vote_type)
                )
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка установки голоса для коммита {commit_id} от {user_id}: {e}")
        return False

def get_vote_counts(commit_id: str) -> Dict[str, int]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    SUM(CASE WHEN vote_type = 1 THEN 1 ELSE 0 END) as likes,
                    SUM(CASE WHEN vote_type = -1 THEN 1 ELSE 0 END) as dislikes
                FROM commit_votes 
                WHERE commit_id = ?
            """, (commit_id,))
            counts = cursor.fetchone()
            return {'likes': counts['likes'] or 0, 'dislikes': counts['dislikes'] or 0}
    except sqlite3.Error:
        return {'likes': 0, 'dislikes': 0}
        
def update_commit_text(commit_id: str, new_text: str) -> bool:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE commits SET commit_text = ? WHERE commit_id = ?", (new_text, commit_id))
            conn.commit()
            return cursor.rowcount > 0
    except sqlite3.Error as e:
        logger.error(f"Ошибка обновления текста коммита {commit_id}: {e}")
        return False
        
def delete_commit_by_id(commit_id: str) -> bool:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM commits WHERE commit_id = ?", (commit_id,))
            conn.commit()
            return cursor.rowcount > 0
    except sqlite3.Error as e:
        logger.error(f"Ошибка удаления коммита {commit_id}: {e}")
        return False

def set_userbot_warning_status(ub_username: str, is_warned: bool, warning_time: Optional[datetime.datetime] = None):
    try:
        with _get_connection() as conn:
            conn.execute(
                "UPDATE userbots SET is_warned = ?, warning_sent_at = ? WHERE ub_username = ?",
                (1 if is_warned else 0, warning_time, ub_username)
            )
            conn.commit()
            return True
    except sqlite3.Error as e:
        logger.error(f"Ошибка установки статуса предупреждения для {ub_username}: {e}")
        return False

def get_warned_userbots() -> List[Dict[str, Any]]:
    try:
        with _get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM userbots WHERE is_warned = 1")
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
    except sqlite3.Error as e:
        logger.error(f"Ошибка получения списка юзерботов с предупреждением: {e}")
        return []