import subprocess
import asyncio
import time
import re
import secrets
import string
import os
import pwd
import sys
import shlex
from html import escape
import datetime
import pytz
import json
import logging
import time
import asyncssh
from urllib.request import urlopen
import tempfile
import uuid
import shutil
from pathlib import Path
import zipfile
import random
import math

import database as db
import server_config

logger_lm = logging.getLogger(__name__)

def get_public_ip():
    try:
        with urlopen("https://api.ipify.org") as response:
            ip = response.read().decode("utf-8")
        logging.info(f"Public IP address detected: {ip}")
        return ip
    except Exception as e:
        logging.critical(f"Could not determine public IP address. Exiting. Error: {e}")
        sys.exit("Critical error: Public IP address could not be determined.")

LOCAL_IP = get_public_ip()
GIT_OVERRIDES_FILE = "git_overrides.json"
STATS_CACHE = {}
CACHE_LIFETIME_SECONDS = 20

def _read_git_overrides():
    if not os.path.exists(GIT_OVERRIDES_FILE):
        return {}
    try:
        with open(GIT_OVERRIDES_FILE, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return {}

def _write_git_overrides(overrides: dict):
    with open(GIT_OVERRIDES_FILE, 'w') as f:
        json.dump(overrides, f, indent=4)

def update_git_repository(ub_type: str, url: str):
    overrides = _read_git_overrides()
    overrides[ub_type] = url
    _write_git_overrides(overrides)

def get_current_repo_url(ub_type: str) -> str:
    repo_map = {
        "hikka": {"url": "https://github.com/qqsharki4/Hikka"},
        "heroku": {"url": "https://github.com/qqsharki4/Heroku"},
        "fox": {"url": "https://github.com/FoxUserbot/FoxUserbot"},
        "legacy": {"url": "https://github.com/Crayz310/Legacy"}
    }
    overrides = _read_git_overrides()
    return overrides.get(ub_type, repo_map.get(ub_type, {}).get("url", "URL не найден"))

async def get_ping_ms(target: str, source_ip: str) -> str:
    ping_cmd = f"ping -c 1 -W 2 {shlex.quote(target)}"
    res = await run_command_async(ping_cmd, source_ip, check_output=False, timeout=5)
    
    if res["success"] and res["output"]:
        match = re.search(r"time=([\d\.]+)\s*ms", res["output"])
        if match:
            return f"{float(match.group(1)):.1f} мс"
    return "❌ Ошибка"

async def fix_tmp_isolated_permissions(server_ip: str):
    """
    Исправляет права доступа к /var/lib/user-tmp для всех пользователей
    """
    fix_cmd = """
    sudo mkdir -p /var/lib/user-tmp
    sudo chmod 755 /var/lib/user-tmp
    sudo chown root:root /var/lib/user-tmp
    sudo setfacl -b /var/lib/user-tmp
    """
    await run_command_async(fix_cmd, server_ip, check_output=False)
    
    # Исправляем права для каждого пользователя ub* и перемонтируем если нужно
    fix_users_cmd = """
    for user_dir in /var/lib/user-tmp/ub*; do
        if [ -d "$user_dir" ]; then
            username=$(basename "$user_dir")
            # Перемонтируем и исправляем права
            sudo umount "$user_dir" 2>/dev/null || true
            sudo mount "$user_dir" 2>/dev/null || true
            sudo chown "$username:$username" "$user_dir"
            sudo chmod 700 "$user_dir"
        fi
    done
    """
    await run_command_async(fix_users_cmd, server_ip, check_output=False)
    
    logging.info(f"Fixed /var/lib/user-tmp permissions on {server_ip}")

async def create_server_user_and_setup_hikka(tg_user_id: int, username_base: str, ub_type: str, server_ip: str, bot=None, chat_id=None):
    ub_username = f"ub{username_base}"
    if await user_exists(ub_username, server_ip) or await db.get_userbot_data(ub_username=ub_username):
        await delete_userbot_full(ub_username, server_ip)
        await asyncio.sleep(1)
    
    await ensure_system_utils(server_ip)
    
    version_cmd = "cat /etc/os-release | grep ^VERSION_ID= | cut -d'\"' -f2"
    version_res = await run_command_async(version_cmd, server_ip)
    ubuntu_version = (version_res.get("output") or "").strip()
    
    python_path_res = await run_command_async("which python3", server_ip)
    if not python_path_res["success"] or not python_path_res["output"]:
        return {"success": False, "message": "Не удалось найти python3 на удаленном сервере."}
    python_executable = python_path_res["output"].strip()
    
    if not (await run_command_async(f'sudo adduser --disabled-password --gecos "" {shlex.quote(ub_username)}', server_ip))["success"]:
        return {"success": False, "message": "Ошибка создания пользователя."}

    image_dir = "/var/lib/ubimages"
    image_file = f"{image_dir}/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    create_img_cmds = [
        f"sudo mkdir -p {image_dir}",
        f"sudo fallocate -l 812M {image_file}",
        f"sudo mkfs.ext4 -F {image_file}",
        f"sudo mount -o loop {image_file} {home_dir}",
        f"sudo chown {ub_username}:{ub_username} {home_dir}"
    ]
    for cmd in create_img_cmds:
        res = await run_command_async(cmd, server_ip)
        if not res["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка при подготовке loop-образа: {cmd}"}

    await cleanup_user_home_if_needed(ub_username, server_ip)

    perm_res = await set_home_directory_permissions(ub_username, server_ip)
    if not perm_res.get("success"):
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка установки прав доступа для пользователя."}

    repo_map = {
        "hikka": {"dir": "Hikka", "module": "hikka"},
        "heroku": {"dir": "Heroku", "module": "heroku"},
        "fox": {"dir": "FoxUserbot", "exec_command": "python3 main.py"},
        "legacy": {"dir": "Legacy", "module": "legacy"}
    }
    
    r_info = repo_map.get(ub_type)
    if not r_info: return {"success": False, "message": f"Неизвестный тип юзербота: {ub_type}"}

    home_dir = f"/home/{ub_username}"
    ub_path = os.path.join(home_dir, r_info['dir'])

    auth_config = server_config.get_server_auth_config(server_ip)
    webui_port = None

    if auth_config.get('mode') == 'port' and ub_type in ['hikka', 'heroku', 'legacy']:
        webui_port = random.randint(20000, 65535)
        logger_lm.info(f"Для {ub_username} на сервере {server_ip} сгенерирован порт {webui_port} для WebUI.")

    if not await db.add_userbot_record(tg_user_id, ub_username, ub_type, ub_path, server_ip, webui_port):
        await run_command_async(f'sudo deluser --remove-home {shlex.quote(ub_username)}', server_ip)
        return {"success": False, "message": "Ошибка записи в БД."}

    source_code_path = f"/root/{r_info['dir']}"
    copy_cmd = f"sudo cp -r {source_code_path} {home_dir}/"
    if not (await run_command_async(copy_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка копирования исходного кода."}
        
    chown_cmd = f"sudo chown -R {ub_username}:{ub_username} {ub_path}"
    if not (await run_command_async(chown_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка установки прав на файлы юзербота."}

    if ubuntu_version == "24.04":
        venv_path = os.path.join(home_dir, "venv")
        # 1. Создать venv от root
        venv_cmd = f"python3 -m venv {shlex.quote(venv_path)}"
        res_venv = await run_command_async(venv_cmd, server_ip)
        if not res_venv["success"]:
            diag_msgs = []
            venv_pkg_check = await run_command_async("dpkg -l | grep python3-venv", server_ip)
            diag_msgs.append(f"python3-venv: {venv_pkg_check.get('output','(none)')}")
            py_check = await run_command_async("which python3", server_ip)
            diag_msgs.append(f"which python3: {py_check.get('output','(none)')}")
            perm_check = await run_command_async(f"ls -ld {home_dir}", server_ip)
            diag_msgs.append(f"ls -ld {home_dir}: {perm_check.get('output','(none)')}")
            space_check = await run_command_async(f"df -h {home_dir}", server_ip)
            diag_msgs.append(f"df -h {home_dir}: {space_check.get('output','(none)')}")
            diag_msgs.append(f"venv stdout: {res_venv.get('output','')}")
            diag_msgs.append(f"venv stderr: {res_venv.get('error','')}")
            logging.error("Ошибка создания venv. Диагностика:\n" + "\n".join(diag_msgs))
            if bot and chat_id:
                await bot.send_message(chat_id, "❌ Ошибка создания venv. Подробности:\n" + "\n".join(diag_msgs))
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": "Ошибка создания venv. См. логи для диагностики."}

        req_path = os.path.join(ub_path, "requirements.txt")
        # 2. Установить зависимости от root
        pip_install_cmd = f"{venv_path}/bin/pip install --upgrade pip && {venv_path}/bin/pip install -r {shlex.quote(req_path)}"
        res_pip = await run_command_async(pip_install_cmd, server_ip, check_output=False, timeout=600)
        if res_pip["exit_status"] != 0:
            logging.warning(f"Команда установки зависимостей для {ub_username} завершилась с кодом {res_pip['exit_status']}. Ошибка: {res_pip['error']}")
        # 3. Сменить владельца venv на ub*
        await run_command_async(f"sudo chown -R {ub_username}:{ub_username} {venv_path}", server_ip)

        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", f"{venv_path}/bin/python")
        else:
            exec_start_cmd = f"{venv_path}/bin/python -m {r_info['module']}"

    else:
        wheels_path = f"/opt/pip_wheels/{ub_type}/"
        install_deps_cmd = (
            f"cd {shlex.quote(ub_path)} && [ -f requirements.txt ] && "
            f"{python_executable} -m pip install --user -q --find-links=\"file://{wheels_path}\" -r requirements.txt"
        )
        # pip install от root
        install_res = await run_command_async(install_deps_cmd, server_ip, check_output=False, timeout=600)
        # сменить владельца .local на ub*
        await run_command_async(f"sudo chown -R {ub_username}:{ub_username} {home_dir}/.local", server_ip)

        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", python_executable)
        else:
            exec_start_cmd = f"{python_executable} -m {r_info['module']}"

    if webui_port:
        exec_start_cmd += f" --port {webui_port}"

    s_name = f"hikka-{ub_username}.service"
    s_content = f"""[Unit]
Description={ub_type.capitalize()} UB for {ub_username}
After=network.target
[Service]
User={ub_username}
Group={ub_username}
WorkingDirectory={ub_path}
ExecStart={exec_start_cmd}
Restart=always
RestartSec=10
Environment=\"PATH=/home/{ub_username}/.local/bin:/usr/bin:/bin:/usr/local/bin\"
StandardOutput=journal
StandardError=journal
MemoryHigh=500M
MemoryMax=512M
MemorySwapMax=0
CPUQuota=60%
[Install]
WantedBy=multi-user.target
"""
    await run_command_async(f"echo '{s_content}' | sudo tee /etc/systemd/system/{s_name} > /dev/null", server_ip)
    await run_command_async(f"sudo chmod 644 /etc/systemd/system/{s_name}", server_ip)

    for cmd in ["sudo systemctl daemon-reload", f"sudo systemctl enable {s_name}", f"sudo systemctl start {s_name}"]:
        res_cmd = await run_command_async(cmd, server_ip)
        if not res_cmd["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка systemd: {cmd}."}
            
    await db.update_userbot_status(ub_username, "running")

    tmp_images_dir = "/var/lib/user-tmp"
    await run_command_async(f"sudo mkdir -p {tmp_images_dir}", server_ip)
    
    tmp_image_file = f"{tmp_images_dir}/{ub_username}-tmp.img"
    create_tmp_image_cmd = f"sudo fallocate -l 120M {tmp_image_file} && sudo mkfs.ext4 -F {tmp_image_file}"
    await run_command_async(create_tmp_image_cmd, server_ip)
    
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    create_mount_point_cmd = f"sudo mkdir -p {isolated_tmp_dir} && sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(create_mount_point_cmd, server_ip)
    
    fix_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_permissions_cmd, server_ip)
    
    setup_isolated_dir_cmd = "sudo mkdir -p /var/lib/user-tmp && sudo chown root:root /var/lib/user-tmp && sudo chmod 755 /var/lib/user-tmp && sudo setfacl -b /var/lib/user-tmp"
    await run_command_async(setup_isolated_dir_cmd, server_ip)
    
    fix_existing_isolated_cmd = "sudo chmod 755 /var/lib/user-tmp 2>/dev/null || true && sudo chown root:root /var/lib/user-tmp 2>/dev/null || true && sudo setfacl -b /var/lib/user-tmp 2>/dev/null || true"
    await run_command_async(fix_existing_isolated_cmd, server_ip)
    
    fix_all_isolated_cmd = "sudo find /var/lib/user-tmp -type d -exec chmod 755 {} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -type d -exec chown root:root {} \\; 2>/dev/null || true"
    await run_command_async(fix_all_isolated_cmd, server_ip)
    
    fix_user_dirs_cmd = f"sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec bash -c 'user=${{1#/var/lib/user-tmp/}}; chown $user:$user $1' _ {{}} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec chmod 700 {{}} \\; 2>/dev/null || true"
    await run_command_async(fix_user_dirs_cmd, server_ip)
    
    fix_mount_point_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_point_cmd, server_ip)
    
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    add_fstab_cmd = f"echo '{fstab_entry}' | sudo tee -a /etc/fstab"
    await run_command_async(add_fstab_cmd, server_ip)
    
    mount_cmd = f"sudo mount {isolated_tmp_dir}"
    await run_command_async(mount_cmd, server_ip)
    
    fix_mount_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_permissions_cmd, server_ip)
    
    quota_cmd = f"sudo quotacheck -cum {isolated_tmp_dir} && sudo quotaon {isolated_tmp_dir} && sudo setquota -u {ub_username} 0 122880 0 0 {isolated_tmp_dir}"
    quota_result = await run_command_async(quota_cmd, server_ip, check_output=False)
    
    if not quota_result.get("success"):
        logging.warning(f"Quota setup failed on {server_ip}: {quota_result.get('error', 'Unknown error')}")
        logging.info(f"Using filesystem size limit instead of quotas for {ub_username}")
    
    remove_old_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_old_pam_cmd, server_ip)

    pam_entries = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries:
        add_pam_cmd = f"echo '{pam_entry}' | sudo tee -a /etc/security/pam_env.conf"
        await run_command_async(add_pam_cmd, server_ip)
    
    check_pam_env_cmd = "grep -q 'pam_env' /etc/pam.d/common-session || echo 'session required pam_env.so' | sudo tee -a /etc/pam.d/common-session"
    await run_command_async(check_pam_env_cmd, server_ip)
    
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    env_vars = f"""
# --- UB: TMP environment variables ---
export TMPDIR={isolated_tmp_dir}
export TMP={isolated_tmp_dir}
export TEMP={isolated_tmp_dir}
# --- END UB ---
"""
    
    for profile in shell_profiles:
        add_env_cmd = f"echo '{env_vars}' | sudo tee -a {profile}"
        await run_command_async(add_env_cmd, server_ip)
    
    source_profile_cmd = f"sudo -u {ub_username} bash -c 'source ~/.bashrc && echo \"TMPDIR set to: $TMPDIR\"'"
    await run_command_async(source_profile_cmd, server_ip, check_output=False)
    
    block_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /tmp"
    await run_command_async(block_tmp_cmd, server_ip)

    block_var_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /var/tmp"
    await run_command_async(block_var_tmp_cmd, server_ip)

    # ПРИМЕНЯЕМ МЕРЫ БЕЗОПАСНОСТИ К НОВОМУ ПОЛЬЗОВАТЕЛЮ
    security_commands = [
        # 1. Устанавливаем nologin shell
        f"sudo usermod -s /usr/sbin/nologin {ub_username}",
        
        # 2. Запрещаем создание .ssh директории
        f"sudo setfacl -m u:{ub_username}:0 /home/{ub_username}/.ssh 2>/dev/null || true",
        
        # 3. Запрещаем доступ к системным директориям
        f"sudo setfacl -m u:{ub_username}:0 /etc 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /var 2>/dev/null || true", 
        f"sudo setfacl -m u:{ub_username}:0 /usr 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /bin 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /sbin 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /lib 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /lib64 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /opt 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /proc 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /sys 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /dev 2>/dev/null || true",
        
        # 4. Ограничиваем права на домашнюю директорию
        f"sudo chmod 750 /home/{ub_username}",
        
        # 5. Запрещаем выполнение скриптов
        f"sudo find /home/{ub_username} -name '*.sh' -exec chmod 600 {{}} \; 2>/dev/null || true",
        f"sudo find /home/{ub_username} -name '*.py' -exec chmod 600 {{}} \; 2>/dev/null || true"
    ]
    
    for cmd in security_commands:
        await run_command_async(cmd, server_ip, check_output=False)

    return {"success": True, "ub_username": ub_username, "webui_port": webui_port}

async def get_server_ping(server_ip: str) -> float | None:
    try:
        ping_cmd = f"ping -c 1 -W 2 {shlex.quote(server_ip)}"
        
        process = await asyncio.create_subprocess_shell(
            ping_cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )
        stdout, _ = await asyncio.wait_for(process.communicate(), timeout=3.0)

        if process.returncode == 0:
            match = re.search(r"time=([\d\.]+)\s*ms", stdout.decode('utf-8', 'ignore'))
            if match:
                return float(match.group(1))
    except (asyncio.TimeoutError, Exception):
        pass

    try:
        start_time = time.perf_counter()
        ssh_res = await run_command_async("echo pong", server_ip, timeout=5)
        end_time = time.perf_counter()
        if ssh_res["success"]:
            ssh_rtt_ms = (end_time - start_time) * 1000
            return ssh_rtt_ms
    except Exception as e:
        logger_lm.error(f"SSH ping fallback failed for {server_ip}: {e}")

    return None

async def get_userbot_resource_usage(ub_username: str, server_ip: str) -> dict:
    defaults = {"cpu": "0.0", "ram_used": "0", "ram_limit": "N/A", "ram_percent": "0.0"}
    service_name = f"hikka-{ub_username}.service"
    
    combined_cmd = f"""
    PID=$(systemctl show {service_name} -p MainPID --value 2>/dev/null || echo 0);
    if [ "$PID" -gt 0 ]; then
        ps -o %cpu= -p $PID;
    else
        echo "0.0";
    fi;
    echo '---SPLITTER---';
    systemd-cgtop -n 1 -b --order=memory | grep {service_name};
    echo '---SPLITTER---';
    grep -oP 'MemoryMax=\K[0-9]+' /etc/systemd/system/{service_name} 2>/dev/null || echo '500'
    """
    
    res = await run_command_async(combined_cmd, server_ip, check_output=False, timeout=15)

    if not res.get("success") or not res.get("output") or res["output"].count('---SPLITTER---') != 2:
        limit_res = await run_command_async(f"grep -oP 'MemoryMax=\K[0-9]+' /etc/systemd/system/{service_name} 2>/dev/null || echo '500'", server_ip, check_output=False, timeout=5)
        if limit_res.get("success") and limit_res.get("output", "").isdigit():
            defaults["ram_limit"] = limit_res["output"].strip()
        return defaults

    try:
        cpu_out, ram_out, limit_out = [p.strip() for p in res["output"].split('---SPLITTER---')]
        
        try:
            cpu = float(cpu_out)
        except (ValueError, TypeError):
            cpu = 0.0

        ram_limit_mb = float(limit_out) if limit_out.isdigit() else 500.0
        if ram_limit_mb == 0: ram_limit_mb = 500.0
        
        ram_parts = ram_out.split()
        ram_used_str = ram_parts[3] if len(ram_parts) > 3 else '0M'
        ram_used_mb = 0.0
        try:
            if 'K' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('K', '')) / 1024
            elif 'G' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('G', '')) * 1024
            elif 'M' in ram_used_str.upper():
                ram_used_mb = float(ram_used_str.upper().replace('M', ''))
        except ValueError:
            ram_used_mb = 0.0

        ram_percent = (ram_used_mb / ram_limit_mb) * 100 if ram_limit_mb > 0 else 0
        
        return {
            "cpu": f"{cpu:.1f}",
            "ram_used": f"{ram_used_mb:.0f}",
            "ram_limit": f"{ram_limit_mb:.0f}",
            "ram_percent": f"{ram_percent:.1f}"
        }
    except Exception as e:
        logger_lm.error(f"Failed to parse resource usage for {ub_username} on {server_ip}: {e}")
        return defaults

async def run_command_async(command_str: str, server_ip: str, timeout=300, user=None, check_output=True, capture_output=True, ssh_pass=None):
    stdout_pipe = asyncio.subprocess.PIPE if capture_output else asyncio.subprocess.DEVNULL
    stderr_pipe = asyncio.subprocess.PIPE if capture_output else asyncio.subprocess.DEVNULL
    
    try:
        if server_ip == LOCAL_IP:
            if user:
                # Принудительно загружаем профиль пользователя для правильных переменных окружения
                final_command = f'sudo -u {shlex.quote(user)} bash -c {shlex.quote("source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; set -o pipefail; " + command_str)}'
            else:
                final_command = f'bash -c {shlex.quote("set -o pipefail; " + command_str)}'
            
            process = await asyncio.create_subprocess_shell(
                final_command, stdout=stdout_pipe, stderr=stderr_pipe
            )
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)
            
            stdout_str = stdout.decode('utf-8', 'ignore').strip() if stdout else ""
            stderr_str = stderr.decode('utf-8', 'ignore').strip() if stderr else ""
            
            if check_output and process.returncode != 0:
                err_msg = stderr_str or stdout_str or f"Команда завершилась с кодом {process.returncode}."
                return {"success": False, "output": stdout_str, "error": err_msg, "exit_status": process.returncode}

            return {"success": True, "output": stdout_str, "error": stderr_str, "exit_status": process.returncode}

        else:
            servers = server_config.get_servers()
            server_details = servers.get(server_ip)
            if not server_details:
                return {"success": False, "error": f"SSH details not found for server {server_ip}", "exit_status": -1}

            ssh_user = server_details.get("ssh_user")
            # Использовать переданный пароль, если есть
            ssh_pass_final = ssh_pass or server_details.get("ssh_pass")

            if not ssh_user:
                return {"success": False, "error": f"SSH user not configured for remote server {server_ip}", "exit_status": -1}

            async with asyncssh.connect(server_ip, username=ssh_user, password=ssh_pass_final, known_hosts=None, connect_timeout=10) as conn:
                if user:
                    safe_user = shlex.quote(user)
                    full_user_command = f"cd /home/{safe_user} && {command_str}"
                    # Принудительно загружаем профиль пользователя для правильных переменных окружения
                    final_command = f"sudo -u {safe_user} bash -c {shlex.quote('source ~/.bashrc 2>/dev/null; source ~/.profile 2>/dev/null; set -o pipefail; ' + full_user_command)}"
                else:
                    final_command = f"bash -c {shlex.quote('set -o pipefail; ' + command_str)}"
                
                result = await asyncio.wait_for(conn.run(final_command, check=check_output), timeout=timeout)

                stdout_str = result.stdout.strip() if result.stdout else ""
                stderr_str = result.stderr.strip() if result.stderr else ""
                
                return {"success": True, "output": stdout_str, "error": stderr_str, "exit_status": result.exit_status}

    except asyncio.TimeoutError:
        logger_lm.error(f"TIMEOUT on [{server_ip}]. Command: {command_str}")
        return {"success": False, "error": "Таймаут команды.", "exit_status": -1}
    except asyncssh.ProcessError as e:
        logger_lm.warning(f"ProcessError on [{server_ip}]. Command: {shlex.quote(command_str)}. Error: {e.stderr}")
        return {"success": False, "output": e.stdout, "error": e.stderr, "exit_status": e.exit_status}
    except Exception as e:
        logger_lm.error(f"EXCEPTION on [{server_ip}]. Command: {shlex.quote(command_str)}", exc_info=True)
        return {"success": False, "error": str(e), "exit_status": -1}

def generate_password(length=20):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{};:,./<>?"
    return ''.join(secrets.choice(alphabet) for i in range(length))

async def get_server_stats(server_ip: str):
    current_time = time.time()
    if server_ip in STATS_CACHE:
        cached_data, timestamp = STATS_CACHE[server_ip]
        if current_time - timestamp < CACHE_LIFETIME_SECONDS:
            logger_lm.debug(f"Returning cached stats for [{server_ip}]")
            return cached_data

    # Оптимизированная команда для сбора всех данных за один вызов
    combined_cmd = (
        "top -bn1 | awk '/^%Cpu/ {print $2+$4}' && "
        "echo '---' && "
        "free -m | awk 'NR==2{printf \"%d|%d\", $3, $2}' && "
        "echo '---' && "
        "df -h / | awk 'NR==2{printf \"%s|%s|%s\", $5, $3, $2}' && "
        "echo '---' && "
        "uptime -p && "
        "echo '---' && "
        "nproc"
    )

    res = await run_command_async(combined_cmd, server_ip, timeout=15)
    
    defaults = {
        "cpu_usage": "0.0", "cpu_cores": "N/A", "ram_percent": "0.0", "ram_used": "0G", "ram_total": "0G",
        "disk_percent": "0%", "disk_used": "0B", "disk_total": "0B", "uptime": "N/A"
    }

    if not res.get("success") or not res.get("output"):
        STATS_CACHE[server_ip] = (defaults, current_time)
        return defaults

    try:
        parts = res['output'].strip().split('---')
        if len(parts) < 5:
             STATS_CACHE[server_ip] = (defaults, current_time)
             return defaults

        cpu_out, ram_out, disk_out, uptime_out, nproc_out = [p.strip() for p in parts]

        cpu_usage = float(cpu_out) if cpu_out else 0.0
        
        ram_data = ram_out.split('|')
        ram_used_mb, ram_total_mb = int(ram_data[0]), int(ram_data[1])
        ram_percent = (ram_used_mb / ram_total_mb * 100) if ram_total_mb > 0 else 0

        disk_data = disk_out.split('|')
        
        uptime = uptime_out.replace("up ", "")
        
        cpu_cores = nproc_out if nproc_out.isdigit() else "N/A"

        stats_data = {
            "cpu_usage": f"{cpu_usage:.1f}",
            "cpu_cores": cpu_cores,
            "ram_percent": f"{ram_percent:.1f}",
            "ram_used": f"{(ram_used_mb/1024):.1f}G",
            "ram_total": f"{(ram_total_mb/1024):.1f}G",
            "disk_percent": disk_data[0],
            "disk_used": disk_data[1],
            "disk_total": disk_data[2],
            "uptime": uptime
        }
        STATS_CACHE[server_ip] = (stats_data, current_time)
        return stats_data
        
    except (ValueError, IndexError, TypeError) as e:
        logging.error(f"Failed to parse combined stats from {server_ip}. Error: {e}. Output: {res.get('output')}")
        STATS_CACHE[server_ip] = (defaults, current_time)
        return defaults

async def get_journal_logs(ub_username: str, server_ip: str, lines: int = 500):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n {lines} --output cat -r"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)
    if res["success"] and res["output"]:
        return res["output"]
    return None

async def get_script_log_file(hikka_path: str, ub_type: str, server_ip: str, lines: int = 500):
    log_file_name_map = {"hikka": "hikka.log", "heroku": "heroku.log"}
    log_file_name = log_file_name_map.get(ub_type, "hikka.log")
    log_file_path = os.path.join(hikka_path, log_file_name)
    cmd = f"sudo tail -n {lines} {log_file_path}"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)
    if res["success"] and res["output"]:
        return "\n".join(reversed(res["output"].strip().split('\n')))
    return None

async def user_exists(username, server_ip):
    res = await run_command_async(f"id -u {shlex.quote(username)}", server_ip, capture_output=False, check_output=False)
    return res["exit_status"] == 0

async def _find_login_url_from_logs(ub_username: str, server_ip: str, patterns: list):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n 200 --output cat"
    res = await run_command_async(cmd, server_ip, timeout=60)
    if res["success"] and res["output"]:
        log = res["output"]
        for p in patterns:
            m = re.search(p, log, re.IGNORECASE)
            if m:
                u = m.group(1) if m.groups() else m.group(0)
                if "github.com" not in u and "pypi.org" not in u:
                    return u
    return None

async def find_login_url_from_journal(ub_username: str, server_ip: str):
    patterns = [
        r'🌐 Public URL: (https://[^\s]+)',
        r'Public URL: (https://[^\s]+)',
        r'🔗 Please visit (https://[^\s]+)',
        r'Please visit (https://[^\s]+)',
        r'Session string generated! You can now login to Hikka using this link: (https://[^\s]+)',
        r'(https://[a-zA-Z0-9.\-]+hik[a-zA-Z0-9.\-/=\?#&%_]+)',
        r'(https://[^\s]+\.lhr\.life)',
        r'(https://[^\s]+\.loca\.lt)'
    ]
    return await _find_login_url_from_logs(ub_username, server_ip, patterns)

async def find_login_url_in_loop(ub_username: str, server_ip: str, ub_type: str):
    end_time = asyncio.get_event_loop().time() + 120
    while asyncio.get_event_loop().time() < end_time:
        url = await find_login_url_from_journal(ub_username, server_ip)
        if url:
            return url
        await asyncio.sleep(5)
    return None

async def check_journal_for_restart(ub_username: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    cmd = f"sudo journalctl -u {s_name} --no-pager -n 50 --output cat"
    res = await run_command_async(cmd, server_ip, timeout=20, check_output=False)
    return res["success"] and res["output"] and re.search(r'restarting', res["output"], re.IGNORECASE)

async def ensure_system_utils(server_ip: str):
    # Проверяем и ждем завершения процесса apt-get если он запущен
    check_apt_cmd = "sudo fuser -v /var/lib/dpkg/lock* /var/lib/apt/lists/lock* 2>/dev/null || echo 'no_locks'"
    apt_check = await run_command_async(check_apt_cmd, server_ip, capture_output=False)
    
    if apt_check.get("success") and "no_locks" not in apt_check.get("output", ""):
        logging.info(f"Waiting for apt processes to complete on {server_ip}...")
        await run_command_async("sudo fuser -k /var/lib/dpkg/lock* /var/lib/apt/lists/lock* 2>/dev/null || true", server_ip, capture_output=False)
        await asyncio.sleep(5)
    
    await run_command_async("sudo apt-get update -qq", server_ip, capture_output=False)
    await run_command_async("sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq git ca-certificates procps python3-pip", server_ip, capture_output=False)

async def set_home_directory_permissions(ub_username: str, server_ip: str):
    home_dir = f"/home/{shlex.quote(ub_username)}"
    command = f"sudo chmod 750 {home_dir}"
    logger_lm.info(f"Setting permissions for user directory: {command} on {server_ip}")
    result = await run_command_async(command, server_ip)
    if not result.get("success"):
        logger_lm.error(f"Failed to set permissions for {home_dir} on {server_ip}: {result.get('error')}")
    return result

async def cleanup_user_home_if_needed(ub_username: str, server_ip: str):
    home_dir = f"/home/{ub_username}"
    df_cmd = f"df --output=avail {home_dir} | tail -1 | awk '{{print int($1/1024)}}'"
    res = await run_command_async(df_cmd, server_ip)
    try:
        free_mb = int(res.get("output", "0"))
    except Exception:
        free_mb = 0
    if free_mb < 300:
        cleanup_cmd = f'''
USER_HOME="{home_dir}";
MIN_FREE_MB=300;
get_free_mb() {{
  df --output=avail "$USER_HOME" | tail -1 | awk '{{print int($1/1024)}}';
}}
free_mb=$(get_free_mb);
while [ "$free_mb" -lt "$MIN_FREE_MB" ]; do
  big_files=$(find "$USER_HOME" -type f -size +199M);
  if [ -n "$big_files" ]; then
    echo "$big_files" | xargs -d '\n' rm -f;
    free_mb=$(get_free_mb);
    continue;
  fi;
  largest=$(find "$USER_HOME" -type f -size +19M -printf "%s %p\\n" | sort -nr | head -1 | awk '{{print $2}}');
  if [ -n "$largest" ]; then
    rm -f "$largest";
    free_mb=$(get_free_mb);
    continue;
  fi;
  newest=$(find "$USER_HOME" -type f -size -20M -printf "%T@ %p\\n" | sort -nr | head -1 | awk '{{print $2}}');
  if [ -n "$newest" ]; then
    rm -f "$newest";
    free_mb=$(get_free_mb);
    continue;
  fi;
  break;
done
'''
        await run_command_async(f"bash -c {shlex.quote(cleanup_cmd)}", server_ip)

async def create_server_user_and_setup_hikka(tg_user_id: int, username_base: str, ub_type: str, server_ip: str, bot=None, chat_id=None):
    ub_username = f"ub{username_base}"
    if await user_exists(ub_username, server_ip) or await db.get_userbot_data(ub_username=ub_username):
        await delete_userbot_full(ub_username, server_ip)
        await asyncio.sleep(1)
    
    await ensure_system_utils(server_ip)
    
    version_cmd = "cat /etc/os-release | grep ^VERSION_ID= | cut -d'\"' -f2"
    version_res = await run_command_async(version_cmd, server_ip)
    ubuntu_version = (version_res.get("output") or "").strip()
    
    python_path_res = await run_command_async("which python3", server_ip)
    if not python_path_res["success"] or not python_path_res["output"]:
        return {"success": False, "message": "Не удалось найти python3 на удаленном сервере."}
    python_executable = python_path_res["output"].strip()
    
    if not (await run_command_async(f'sudo adduser --disabled-password --gecos "" {shlex.quote(ub_username)}', server_ip))["success"]:
        return {"success": False, "message": "Ошибка создания пользователя."}

    image_dir = "/var/lib/ubimages"
    image_file = f"{image_dir}/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    create_img_cmds = [
        f"sudo mkdir -p {image_dir}",
        f"sudo fallocate -l 812M {image_file}",
        f"sudo mkfs.ext4 -F {image_file}",
        f"sudo mount -o loop {image_file} {home_dir}",
        f"sudo chown {ub_username}:{ub_username} {home_dir}"
    ]
    for cmd in create_img_cmds:
        res = await run_command_async(cmd, server_ip)
        if not res["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка при подготовке loop-образа: {cmd}"}

    await cleanup_user_home_if_needed(ub_username, server_ip)

    perm_res = await set_home_directory_permissions(ub_username, server_ip)
    if not perm_res.get("success"):
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка установки прав доступа для пользователя."}

    repo_map = {
        "hikka": {"dir": "Hikka", "module": "hikka"},
        "heroku": {"dir": "Heroku", "module": "heroku"},
        "fox": {"dir": "FoxUserbot", "exec_command": "python3 main.py"},
        "legacy": {"dir": "Legacy", "module": "legacy"}
    }
    
    r_info = repo_map.get(ub_type)
    if not r_info: return {"success": False, "message": f"Неизвестный тип юзербота: {ub_type}"}

    home_dir = f"/home/{ub_username}"
    ub_path = os.path.join(home_dir, r_info['dir'])

    auth_config = server_config.get_server_auth_config(server_ip)
    webui_port = None

    if auth_config.get('mode') == 'port' and ub_type in ['hikka', 'heroku', 'legacy']:
        webui_port = random.randint(20000, 65535)
        logger_lm.info(f"Для {ub_username} на сервере {server_ip} сгенерирован порт {webui_port} для WebUI.")

    if not await db.add_userbot_record(tg_user_id, ub_username, ub_type, ub_path, server_ip, webui_port):
        await run_command_async(f'sudo deluser --remove-home {shlex.quote(ub_username)}', server_ip)
        return {"success": False, "message": "Ошибка записи в БД."}

    source_code_path = f"/root/{r_info['dir']}"
    copy_cmd = f"sudo cp -r {source_code_path} {home_dir}/"
    if not (await run_command_async(copy_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка копирования исходного кода."}
        
    chown_cmd = f"sudo chown -R {ub_username}:{ub_username} {ub_path}"
    if not (await run_command_async(chown_cmd, server_ip))["success"]:
        await delete_userbot_full(ub_username, server_ip)
        return {"success": False, "message": "Ошибка установки прав на файлы юзербота."}

    if ubuntu_version == "24.04":
        venv_path = os.path.join(home_dir, "venv")
        # 1. Создать venv от root
        venv_cmd = f"python3 -m venv {shlex.quote(venv_path)}"
        res_venv = await run_command_async(venv_cmd, server_ip)
        if not res_venv["success"]:
            diag_msgs = []
            venv_pkg_check = await run_command_async("dpkg -l | grep python3-venv", server_ip)
            diag_msgs.append(f"python3-venv: {venv_pkg_check.get('output','(none)')}")
            py_check = await run_command_async("which python3", server_ip)
            diag_msgs.append(f"which python3: {py_check.get('output','(none)')}")
            perm_check = await run_command_async(f"ls -ld {home_dir}", server_ip)
            diag_msgs.append(f"ls -ld {home_dir}: {perm_check.get('output','(none)')}")
            space_check = await run_command_async(f"df -h {home_dir}", server_ip)
            diag_msgs.append(f"df -h {home_dir}: {space_check.get('output','(none)')}")
            diag_msgs.append(f"venv stdout: {res_venv.get('output','')}")
            diag_msgs.append(f"venv stderr: {res_venv.get('error','')}")
            logging.error("Ошибка создания venv. Диагностика:\n" + "\n".join(diag_msgs))
            if bot and chat_id:
                await bot.send_message(chat_id, "❌ Ошибка создания venv. Подробности:\n" + "\n".join(diag_msgs))
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": "Ошибка создания venv. См. логи для диагностики."}

        req_path = os.path.join(ub_path, "requirements.txt")
        # 2. Установить зависимости от root
        pip_install_cmd = f"{venv_path}/bin/pip install --upgrade pip && {venv_path}/bin/pip install -r {shlex.quote(req_path)}"
        res_pip = await run_command_async(pip_install_cmd, server_ip, check_output=False, timeout=600)
        if res_pip["exit_status"] != 0:
            logging.warning(f"Команда установки зависимостей для {ub_username} завершилась с кодом {res_pip['exit_status']}. Ошибка: {res_pip['error']}")
        # 3. Сменить владельца venv на ub*
        await run_command_async(f"sudo chown -R {ub_username}:{ub_username} {venv_path}", server_ip)

        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", f"{venv_path}/bin/python")
        else:
            exec_start_cmd = f"{venv_path}/bin/python -m {r_info['module']}"
    else:
        wheels_path = f"/opt/pip_wheels/{ub_type}/"
        install_deps_cmd = f"""
        cd {shlex.quote(ub_path)} && [ -f requirements.txt ] && {{
            mkdir -p /home/{ub_username}/.local/lib/python3.10/site-packages;
            chown {ub_username}:{ub_username} /home/{ub_username}/.local/lib/python3.10/site-packages;
            WHEELS_PATH="{wheels_path}";
            if [ -d "$WHEELS_PATH" ]; then
                echo "Installing dependencies using local wheels cache...";
                {python_executable} -m pip install -q --find-links="file://$WHEELS_PATH" -r requirements.txt --target=/home/{ub_username}/.local/lib/python3.10/site-packages;
            else
                echo "Local wheels cache not found. Installing from PyPI...";
                {python_executable} -m pip install -q -r requirements.txt --target=/home/{ub_username}/.local/lib/python3.10/site-packages;
            fi
        }}
        """
        install_res = await run_command_async(install_deps_cmd, server_ip, user=None, check_output=False, timeout=600)
        
        if install_res["exit_status"] != 0:
            logging.error(f"Команда установки зависимостей для {ub_username} завершилась с кодом {install_res['exit_status']}. Ошибка: {install_res['error']}")
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка установки зависимостей: {install_res['error']}"}

        if "exec_command" in r_info:
            exec_start_cmd = r_info["exec_command"].replace("python3", python_executable)
        else:
            exec_start_cmd = f"{python_executable} -m {r_info['module']}"

    if webui_port:
        exec_start_cmd += f" --port {webui_port}"

    s_name = f"hikka-{ub_username}.service"
    s_content = f"""[Unit]
Description={ub_type.capitalize()} UB for {ub_username}
After=network.target
[Service]
User={ub_username}
Group={ub_username}
WorkingDirectory={ub_path}
ExecStart={exec_start_cmd}
Restart=always
RestartSec=10
Environment=\"PATH=/home/{ub_username}/.local/bin:/usr/bin:/bin:/usr/local/bin\"
StandardOutput=journal
StandardError=journal
MemoryHigh=500M
MemoryMax=512M
MemorySwapMax=0
CPUQuota=60%
[Install]
WantedBy=multi-user.target
"""
    await run_command_async(f"echo '{s_content}' | sudo tee /etc/systemd/system/{s_name} > /dev/null", server_ip)
    await run_command_async(f"sudo chmod 644 /etc/systemd/system/{s_name}", server_ip)

    for cmd in ["sudo systemctl daemon-reload", f"sudo systemctl enable {s_name}", f"sudo systemctl start {s_name}"]:
        res_cmd = await run_command_async(cmd, server_ip)
        if not res_cmd["success"]:
            await delete_userbot_full(ub_username, server_ip)
            return {"success": False, "message": f"Ошибка systemd: {cmd}."}
            
    await db.update_userbot_status(ub_username, "running")

    tmp_images_dir = "/var/lib/user-tmp"
    await run_command_async(f"sudo mkdir -p {tmp_images_dir}", server_ip)
    
    tmp_image_file = f"{tmp_images_dir}/{ub_username}-tmp.img"
    create_tmp_image_cmd = f"sudo fallocate -l 120M {tmp_image_file} && sudo mkfs.ext4 -F {tmp_image_file}"
    await run_command_async(create_tmp_image_cmd, server_ip)
    
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    create_mount_point_cmd = f"sudo mkdir -p {isolated_tmp_dir} && sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(create_mount_point_cmd, server_ip)
    
    fix_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_permissions_cmd, server_ip)
    
    setup_isolated_dir_cmd = "sudo mkdir -p /var/lib/user-tmp && sudo chown root:root /var/lib/user-tmp && sudo chmod 755 /var/lib/user-tmp && sudo setfacl -b /var/lib/user-tmp"
    await run_command_async(setup_isolated_dir_cmd, server_ip)
    
    fix_existing_isolated_cmd = "sudo chmod 755 /var/lib/user-tmp 2>/dev/null || true && sudo chown root:root /var/lib/user-tmp 2>/dev/null || true && sudo setfacl -b /var/lib/user-tmp 2>/dev/null || true"
    await run_command_async(fix_existing_isolated_cmd, server_ip)
    
    fix_all_isolated_cmd = "sudo find /var/lib/user-tmp -type d -exec chmod 755 {} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -type d -exec chown root:root {} \\; 2>/dev/null || true"
    await run_command_async(fix_all_isolated_cmd, server_ip)
    
    fix_user_dirs_cmd = f"sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec bash -c 'user=${{1#/var/lib/user-tmp/}}; chown $user:$user $1' _ {{}} \\; 2>/dev/null || true && sudo find /var/lib/user-tmp -maxdepth 1 -type d -name 'ub*' -exec chmod 700 {{}} \\; 2>/dev/null || true"
    await run_command_async(fix_user_dirs_cmd, server_ip)
    
    fix_mount_point_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_point_cmd, server_ip)
    
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    add_fstab_cmd = f"echo '{fstab_entry}' | sudo tee -a /etc/fstab"
    await run_command_async(add_fstab_cmd, server_ip)
    
    mount_cmd = f"sudo mount {isolated_tmp_dir}"
    await run_command_async(mount_cmd, server_ip)
    
    fix_mount_permissions_cmd = f"sudo chown {ub_username}:{ub_username} {isolated_tmp_dir} && sudo chmod 700 {isolated_tmp_dir}"
    await run_command_async(fix_mount_permissions_cmd, server_ip)
    
    quota_cmd = f"sudo quotacheck -cum {isolated_tmp_dir} && sudo quotaon {isolated_tmp_dir} && sudo setquota -u {ub_username} 0 122880 0 0 {isolated_tmp_dir}"
    quota_result = await run_command_async(quota_cmd, server_ip, check_output=False)
    
    if not quota_result.get("success"):
        logging.warning(f"Quota setup failed on {server_ip}: {quota_result.get('error', 'Unknown error')}")
        logging.info(f"Using filesystem size limit instead of quotas for {ub_username}")
    
    remove_old_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_old_pam_cmd, server_ip)

    pam_entries = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries:
        add_pam_cmd = f"echo '{pam_entry}' | sudo tee -a /etc/security/pam_env.conf"
        await run_command_async(add_pam_cmd, server_ip)
    
    check_pam_env_cmd = "grep -q 'pam_env' /etc/pam.d/common-session || echo 'session required pam_env.so' | sudo tee -a /etc/pam.d/common-session"
    await run_command_async(check_pam_env_cmd, server_ip)
    
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    env_vars = f"""
# --- UB: TMP environment variables ---
export TMPDIR={isolated_tmp_dir}
export TMP={isolated_tmp_dir}
export TEMP={isolated_tmp_dir}
# --- END UB ---
"""
    
    for profile in shell_profiles:
        add_env_cmd = f"echo '{env_vars}' | sudo tee -a {profile}"
        await run_command_async(add_env_cmd, server_ip)
    
    source_profile_cmd = f"sudo -u {ub_username} bash -c 'source ~/.bashrc && echo \"TMPDIR set to: $TMPDIR\"'"
    await run_command_async(source_profile_cmd, server_ip, check_output=False)
    
    block_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /tmp"
    await run_command_async(block_tmp_cmd, server_ip)

    block_var_tmp_cmd = f"sudo setfacl -m u:{ub_username}:0 /var/tmp"
    await run_command_async(block_var_tmp_cmd, server_ip)

    # ПРИМЕНЯЕМ МЕРЫ БЕЗОПАСНОСТИ К НОВОМУ ПОЛЬЗОВАТЕЛЮ
    security_commands = [
        # 1. Устанавливаем nologin shell
        f"sudo usermod -s /usr/sbin/nologin {ub_username}",
        
        # 2. Запрещаем создание .ssh директории
        f"sudo setfacl -m u:{ub_username}:0 /home/{ub_username}/.ssh 2>/dev/null || true",
        
        # 3. Запрещаем доступ к системным директориям
        f"sudo setfacl -m u:{ub_username}:0 /etc 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /var 2>/dev/null || true", 
        f"sudo setfacl -m u:{ub_username}:0 /usr 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /bin 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /sbin 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /lib 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /lib64 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /opt 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /proc 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /sys 2>/dev/null || true",
        f"sudo setfacl -m u:{ub_username}:0 /dev 2>/dev/null || true",
        
        # 4. Ограничиваем права на домашнюю директорию
        f"sudo chmod 750 /home/{ub_username}",
        
        # 5. Запрещаем выполнение скриптов
        f"sudo find /home/{ub_username} -name '*.sh' -exec chmod 600 {{}} \; 2>/dev/null || true",
        f"sudo find /home/{ub_username} -name '*.py' -exec chmod 600 {{}} \; 2>/dev/null || true"
    ]
    
    for cmd in security_commands:
        await run_command_async(cmd, server_ip, check_output=False)

    return {"success": True, "ub_username": ub_username, "webui_port": webui_port}

async def is_service_active(service_name: str, server_ip: str):
    res = await run_command_async(f"sudo systemctl is-active {service_name}", server_ip, check_output=False)
    return res["success"] and res["output"] == "active"



async def delete_userbot_full(ub_username: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    
    # 1. Останавливаем и отключаем systemd сервис
    await asyncio.gather(
        run_command_async(f"sudo systemctl stop {s_name}", server_ip, check_output=False),
        run_command_async(f"sudo systemctl disable {s_name}", server_ip, check_output=False)
    )
    
    # 2. Убиваем все процессы пользователя
    if await user_exists(ub_username, server_ip):
        await run_command_async(f'sudo pkill -u {ub_username}', server_ip, check_output=False)
        await asyncio.sleep(1)
        await run_command_async(f'sudo pkill -9 -u {ub_username}', server_ip, check_output=False)
        await asyncio.sleep(1)
    
    # 3. Удаляем systemd файл и перезагружаем daemon
    await asyncio.gather(
        run_command_async(f"sudo rm -f /etc/systemd/system/{s_name}", server_ip, check_output=False),
        run_command_async("sudo systemctl daemon-reload", server_ip, check_output=False),
        clear_journal_logs_for_service(s_name, server_ip)
    )

    # 4. Размонтируем и удаляем loop-образ (если существует)
    image_file = f"/var/lib/ubimages/{ub_username}.img"
    home_dir = f"/home/{ub_username}"
    await run_command_async(f"sudo umount {home_dir}", server_ip, check_output=False)
    await run_command_async(f"sudo rm -f {image_file}", server_ip, check_output=False)

    # 5. Очищаем изолированный tmp и ACL блокировки
    isolated_tmp_dir = f"/var/lib/user-tmp/{ub_username}"
    tmp_image_file = f"/var/lib/user-tmp/{ub_username}-tmp.img"
    
    # 5.1. Размонтируем изолированный tmp
    await run_command_async(f"sudo umount {isolated_tmp_dir}", server_ip, check_output=False)
    
    # 5.2. Удаляем ACL блокировки для системного /tmp
    remove_acl_cmd = f"sudo setfacl -x u:{ub_username} /tmp 2>/dev/null || true && sudo setfacl -x d:u:{ub_username} /tmp 2>/dev/null || true"
    await run_command_async(remove_acl_cmd, server_ip, check_output=False)
    
    # 5.3. Удаляем ACL блокировки для системного /var/tmp
    remove_var_tmp_acl_cmd = f"sudo setfacl -x u:{ub_username} /var/tmp 2>/dev/null || true"
    await run_command_async(remove_var_tmp_acl_cmd, server_ip, check_output=False)
    
    # 5.4. Удаляем запись из /etc/fstab
    fstab_entry = f"{tmp_image_file} {isolated_tmp_dir} ext4 loop,usrquota,nodev,nosuid,noexec 0 0"
    remove_fstab_cmd = f"sudo sed -i 's|{fstab_entry}|' /etc/fstab"
    await run_command_async(remove_fstab_cmd, server_ip, check_output=False)
    
    # 5.5. Удаляем записи из PAM
    pam_entries_to_remove = [
        f"{ub_username} DEFAULT=TMPDIR OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TMP OVERRIDE={isolated_tmp_dir}",
        f"{ub_username} DEFAULT=TEMP OVERRIDE={isolated_tmp_dir}"
    ]
    for pam_entry in pam_entries_to_remove:
        remove_pam_cmd = f"sudo sed -i '/{pam_entry}/d' /etc/security/pam_env.conf"
        await run_command_async(remove_pam_cmd, server_ip, check_output=False)
    
    # 5.6. Удаляем все возможные строки для пользователя (на случай дубликатов)
    remove_all_pam_cmd = f"sudo sed -i '/^{ub_username} DEFAULT=TMPDIR OVERRIDE=/d;/^{ub_username} DEFAULT=TMP OVERRIDE=/d;/^{ub_username} DEFAULT=TEMP OVERRIDE=/d' /etc/security/pam_env.conf"
    await run_command_async(remove_all_pam_cmd, server_ip, check_output=False)
    
    # 5.7. Удаляем переменные окружения из shell-профилей пользователя
    home_dir = f"/home/{ub_username}"
    shell_profiles = [
        f"{home_dir}/.profile",
        f"{home_dir}/.bashrc",
        f"{home_dir}/.bash_profile"
    ]
    
    for profile in shell_profiles:
        remove_env_cmd = f"sudo sed -i '/# --- UB: TMP environment variables ---/,/# --- END UB ---/d' {profile}"
        await run_command_async(remove_env_cmd, server_ip, check_output=False)

    # 5.8. Удаляем файлы и директории изолированного tmp
    cleanup_cmds = [
        f"sudo rm -rf {isolated_tmp_dir}",
        f"sudo rm -f {tmp_image_file}",
        f"sudo rmdir /var/lib/user-tmp 2>/dev/null || true"  # удаляем /var/lib/user-tmp если пустой
    ]
    for cmd in cleanup_cmds:
        await run_command_async(cmd, server_ip, check_output=False)

    # 6. Удаляем пользователя и его домашнюю директорию
    if await user_exists(ub_username, server_ip):
        await run_command_async(f'sudo deluser --remove-home {ub_username}', server_ip, check_output=False)
        
    # 7. Удаляем запись из базы данных
    await db.delete_userbot_record(ub_username)
    return {"success": True, "message": f"UB {ub_username} полностью удален."}

async def manage_ub_service(ub_username: str, action: str, server_ip: str):
    s_name = f"hikka-{ub_username}.service"
    if action not in ["start", "stop", "restart"]:
        return {"success": False, "message": "Неверное действие."}
    # --- Очистка домашней директории при нехватке места перед запуском/рестартом ---
    if action in ["start", "restart"]:
        await cleanup_user_home_if_needed(ub_username, server_ip)
    res = await run_command_async(f"sudo systemctl {action} {s_name}", server_ip)
    if not res["success"]:
        await db.update_userbot_status(ub_username, "error")
        return {"success": False, "message": f"Ошибка {action}"}
    
    is_active_after = await is_service_active(s_name, server_ip)
    new_stat = "running" if is_active_after and action != "stop" else "stopped"
    
    if action == "stop" and new_stat == "stopped":
        await db.update_userbot_status_with_time(ub_username, new_stat, datetime.datetime.now())
    elif action == "start" and new_stat == "running":
        await db.update_userbot_started_time(ub_username, datetime.datetime.now())
    else:
        await db.update_userbot_status(ub_username, new_stat)
    
    return {"success": True}

async def check_for_session_file(ub_username: str, server_ip: str) -> bool:
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or not await user_exists(ub_username, server_ip): return False
    ub_type, hikka_path = ub_data.get("ub_type"), ub_data.get("hikka_path")
    if not ub_type or not hikka_path: return False
    
    cmd = f'sudo find {shlex.quote(hikka_path)} -maxdepth 1 \\( -name "*.session" -o -name "heroku*" \\) -print -quit'
    res = await run_command_async(cmd, server_ip, check_output=False)
    return bool(res["success"] and res["output"])
    
async def get_all_userbots_cpu_usage(server_ip: str):
    cmd = "ps -eo user:20,pcpu,comm --no-headers | grep '^ub'"
    res = await run_command_async(cmd, server_ip, check_output=False, timeout=20)

    if not res["success"] or not res["output"]:
        logging.warning(f"Could not get CPU usage from {server_ip} using 'ps'.")
        return {}
    
    cpu_usage_map = {}
    lines = res["output"].strip().split('\n')

    for line in lines:
        parts = line.strip().split()
        if len(parts) >= 2:
            try:
                username = parts[0]
                cpu_percent = float(parts[1])
                cpu_usage_map[username] = cpu_usage_map.get(username, 0) + cpu_percent
            except (ValueError, IndexError):
                continue
    return cpu_usage_map
    
async def clear_journal_logs_for_service(service_name: str, server_ip: str):
    logger_lm.info(f"Очистка логов для службы {service_name} на сервере {server_ip}...")
    cmd = f"sudo journalctl --rotate && sudo journalctl -u {shlex.quote(service_name)} --vacuum-time=1s"
    await run_command_async(cmd, server_ip, check_output=False)
    logger_lm.info(f"Логи для {service_name} очищены.")
    
async def get_batch_service_statuses(service_names: list[str], server_ip: str) -> dict[str, bool]:
    if not service_names:
        return {}
    
    command = "systemctl list-units --full --all --plain --no-legend " + " ".join(shlex.quote(s) for s in service_names)
    res = await run_command_async(command, server_ip, check_output=False, timeout=45)
    
    statuses = {name: False for name in service_names}
    
    if res["success"] and res["output"]:
        for line in res["output"].strip().split('\n'):
            parts = line.split()
            if len(parts) >= 4:
                service_name = parts[0]
                active_state = parts[2]
                if service_name in statuses and active_state == 'active':
                    statuses[service_name] = True
    return statuses



def _load_heroku_db(project_path: Path, tg_id: str) -> dict:
    db_path = project_path / f"config-{tg_id}.json"
    if not db_path.exists():
        # Отладочный вывод
        import logging, os
        files = [f.name for f in project_path.glob('config-*.json')]
        try:
            dir_stat = os.stat(project_path)
            file_stat = os.stat(db_path) if db_path.exists() else None
        except Exception as e:
            dir_stat = str(e)
            file_stat = None
        debug_msg = f"[DEBUG] _load_heroku_db: project_path={project_path}, tg_id={tg_id}, db_path={db_path}, files={files}, dir_stat={dir_stat}, file_stat={file_stat}"
        logging.error(debug_msg)
        print(debug_msg)
        raise FileNotFoundError(f"Не найден файл config-<tg_id>.json в {project_path}")
    with open(db_path, "r", encoding="utf-8") as f:
        db = json.load(f)
    return db

def _backup_db(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    db = _load_heroku_db(project_path, tg_id)
    fname = f"db-backup-{datetime.datetime.now():%d-%m-%Y-%H-%M}.json"
    out_path = out_dir / fname
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(db, f, ensure_ascii=True, indent=None, separators=(", ", ": "))
    return out_path

def _backup_mods(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    loaded_modules_dir = project_path / "loaded_modules"
    mods_zip_path = out_dir / f"mods-{datetime.datetime.now():%d-%m-%Y-%H-%M}.zip"
    db = _load_heroku_db(project_path, tg_id)
    db_mods = db.get("LoaderMod", {}).get("loaded_modules", {})
    with zipfile.ZipFile(mods_zip_path, "w", zipfile.ZIP_DEFLATED) as mods_zip:
        found = False
        for file in loaded_modules_dir.glob(f"*{tg_id}.py"):
            mods_zip.write(file, file.name)
            found = True
        mods_zip.writestr("db_mods.json", json.dumps(db_mods, ensure_ascii=True, indent=None, separators=(", ", ": ")))
    return mods_zip_path

def _backup_all(project_path: Path, tg_id: str, out_dir: Path) -> Path:
    db = _load_heroku_db(project_path, tg_id)
    db_bytes = json.dumps(db, ensure_ascii=True, indent=None, separators=(", ", ": ")).encode()
    loaded_modules_dir = project_path / "loaded_modules"
    mods_zip_path = out_dir / "mods.zip"
    db_mods = db.get("LoaderMod", {}).get("loaded_modules", {})
    with zipfile.ZipFile(mods_zip_path, "w", zipfile.ZIP_DEFLATED) as mods_zip:
        found = False
        for file in loaded_modules_dir.glob(f"*{tg_id}.py"):
            mods_zip.write(file, file.name)
            found = True
        mods_zip.writestr("db_mods.json", json.dumps(db_mods, ensure_ascii=True, indent=None, separators=(", ", ": ")))
    backup_zip_path = out_dir / f"backup-all-{datetime.datetime.now():%d-%m-%Y-%H-%M}.zip"
    with zipfile.ZipFile(backup_zip_path, "w", zipfile.ZIP_DEFLATED) as backup_zip:
        backup_zip.writestr("db.json", db_bytes)
        with open(mods_zip_path, "rb") as mods_file:
            backup_zip.writestr("mods.zip", mods_file.read())
    os.remove(mods_zip_path)
    return backup_zip_path

async def make_heroku_backup(ub_username: str, server_ip: str, backup_type: str = "all") -> tuple[str, str]:
    """
    Создаёт резервную копию Heroku-юзербота (db, mods, all) во временной уникальной папке в /tmp.
    Возвращает (путь к файлу, имя файла для пользователя).
    После отправки файл и папка должны быть удалены.
    """
    import asyncio
    import aiofiles
    import logging
    # Получаем данные о юзерботе
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or ub_data.get("ub_type") != "heroku":
        raise ValueError("Бэкап доступен только для Heroku-юзерботов.")
    hikka_path = ub_data.get("hikka_path")
    if not hikka_path:
        raise ValueError("Не найдена директория Heroku-юзербота.")
    tg_id = None
    project_path = Path(hikka_path)
    # Логируем содержимое директории для диагностики
    try:
        files_in_dir = list(project_path.glob("config-*.json"))
        logging.info(f"[make_heroku_backup] Поиск config-<tg_id>.json в {hikka_path}. Найдено файлов: {[f.name for f in files_in_dir]}")
    except Exception as e:
        logging.error(f"[make_heroku_backup] Ошибка при просмотре директории {hikka_path}: {e}")
        files_in_dir = []
    # Определяем tg_id по файлу config-<tg_id>.json
    for file in files_in_dir:
        name = file.name
        if name.startswith("config-") and name.endswith(".json"):
            try:
                tg_id_candidate = name[7:-5]
                if tg_id_candidate.isdigit():
                    tg_id = tg_id_candidate
                    break
                else:
                    logging.warning(f"[make_heroku_backup] Файл {name} не содержит числовой tg_id")
            except Exception as e:
                logging.error(f"[make_heroku_backup] Ошибка при разборе имени файла {name}: {e}")
    if not tg_id:
        # Диагностика через SSH
        ls_cmd = f"ls -l {hikka_path}"
        stat_cmd = f"stat {hikka_path} || true"
        ls_res = await run_command_async(ls_cmd, server_ip, check_output=False)
        stat_res = await run_command_async(stat_cmd, server_ip, check_output=False)
        diag = f"\n[DIAG] ls -l: {ls_res.get('output','')}\n[DIAG] stat: {stat_res.get('output','')}"
        raise FileNotFoundError(f"[make_heroku_backup] Не найден файл config-<tg_id>.json в {hikka_path}. Содержимое директории: {[f.name for f in files_in_dir]}{diag}")
    # Создаём уникальную временную папку
    unique = uuid.uuid4().hex[:8]
    tmp_dir = Path("/tmp") / f"heroku_backup_{tg_id}_{unique}"
    tmp_dir.mkdir(parents=True, exist_ok=True)
    # Делаем бэкап
    if backup_type == "db":
        backup_path = _backup_db(project_path, tg_id, tmp_dir)
    elif backup_type == "mods":
        backup_path = _backup_mods(project_path, tg_id, tmp_dir)
    elif backup_type == "all":
        backup_path = _backup_all(project_path, tg_id, tmp_dir)
    else:
        raise ValueError("Некорректный тип бэкапа. Используйте 'db', 'mods' или 'all'.")
    return str(backup_path), backup_path.name

def cleanup_heroku_backup_file(backup_file_path: str):
    """
    Удаляет временную папку, в которой лежит backup_file_path.
    """
    path = Path(backup_file_path)
    tmp_dir = path.parent
    if tmp_dir.exists() and str(tmp_dir).startswith("/tmp/heroku_backup_"):
        shutil.rmtree(tmp_dir, ignore_errors=True)

def generate_strong_password(length=28):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{};:,./<>?"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

async def secure_and_prepare_server(ip, old_ssh_user, old_ssh_pass):
    import asyncssh
    import shlex
    import logging

    new_password = generate_strong_password(28)
    pubkey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIF8o56JaCLaEta/fNV9I235ngQLcjqmOutIiGkYpdSc8 qqsharki4@gmail.com"
    sshd_config = '''Port 22
AddressFamily any
ListenAddress 0.0.0.0
Protocol 2
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
LoginGraceTime 60
PermitRootLogin yes
StrictModes yes
MaxAuthTries 3
MaxSessions 5
PubkeyAuthentication yes
PasswordAuthentication yes
PermitRootLogin yes
PermitEmptyPasswords no
KbdInteractiveAuthentication no
UsePAM yes
X11Forwarding no
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
ClientAliveInterval 300
ClientAliveCountMax 2
Compression no
Subsystem sftp /usr/lib/openssh/sftp-server
AllowAgentForwarding no
AllowTcpForwarding yes
GatewayPorts no
PermitTunnel no'''

    try:
        async with asyncssh.connect(ip, username=old_ssh_user, password=old_ssh_pass, known_hosts=None) as conn:
            # 1. Удаление всех ключей из /root/.ssh и /home/*/.ssh
            try:
                res = await conn.run('rm -rf /root/.ssh/*', check=False)
                logging.info(f"rm root keys: {res.stdout} {res.stderr}")
                res = await conn.run('for d in /home/*/.ssh; do rm -rf "$d"/*; done', check=False)
                logging.info(f"rm home keys: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при удалении ssh-ключей: {e}")
                raise

            # 2. Запрет SSH для всех кроме root
            try:
                res = await conn.run('for u in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do sudo usermod -s /usr/sbin/nologin $u; done', check=False)
                logging.info(f"usermod: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при usermod: {e}")
                raise

            # 3. Добавление публичного ключа
            try:
                res = await conn.run('mkdir -p /root/.ssh && chmod 700 /root/.ssh', check=True)
                logging.info(f"mkdir .ssh: {res.stdout} {res.stderr}")
                res = await conn.run(f'echo "{pubkey}" > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys', check=True)
                logging.info(f"add pubkey: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при добавлении публичного ключа: {e}")
                raise

            # 4. Запись sshd_config
            try:
                res = await conn.run(f'echo {shlex.quote(sshd_config)} | sudo tee /etc/ssh/sshd_config', check=True)
                logging.info(f"sshd_config: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при записи sshd_config: {e}")
                raise

            # 5. ДОПОЛНИТЕЛЬНЫЕ МЕРЫ БЕЗОПАСНОСТИ
            try:
                # 5.1. Запрет создания .ssh директорий для всех пользователей кроме root
                ssh_restrictions = '''
# Запрет создания .ssh директорий для всех пользователей кроме root
for user in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do
    if [ -d "/home/$user/.ssh" ]; then
        rm -rf "/home/$user/.ssh"
    fi
    # Запрещаем создание .ssh директорий через ACL
    setfacl -m u:$user:0 /home/$user/.ssh 2>/dev/null || true
done
'''

                # 5.2. Отключение unshare для всех пользователей кроме root
                unshare_restrictions = '''
# Удаляем unshare для всех пользователей кроме root
if command -v unshare >/dev/null 2>&1; then
    chmod 700 /usr/bin/unshare
    # Запрещаем выполнение unshare через capabilities
    setcap -r /usr/bin/unshare 2>/dev/null || true
fi

# Альтернативно - полностью удаляем unshare
rm -f /usr/bin/unshare 2>/dev/null || true
'''

                # 5.3. Запрет создания файлов/папок вне домашних директорий
                file_restrictions = '''
# Запрет создания файлов/папок вне домашних директорий для всех пользователей кроме root
for user in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do
    home_dir="/home/$user"
    if [ -d "$home_dir" ]; then
        # Разрешаем доступ только к домашней директории
        chmod 750 "$home_dir"
        # Запрещаем доступ к системным директориям
        setfacl -m u:$user:0 /etc 2>/dev/null || true
        setfacl -m u:$user:0 /var 2>/dev/null || true
        setfacl -m u:$user:0 /usr 2>/dev/null || true
        setfacl -m u:$user:0 /bin 2>/dev/null || true
        setfacl -m u:$user:0 /sbin 2>/dev/null || true
        setfacl -m u:$user:0 /lib 2>/dev/null || true
        setfacl -m u:$user:0 /lib64 2>/dev/null || true
        setfacl -m u:$user:0 /opt 2>/dev/null || true
        setfacl -m u:$user:0 /tmp 2>/dev/null || true
        setfacl -m u:$user:0 /var/tmp 2>/dev/null || true
        setfacl -m u:$user:0 /proc 2>/dev/null || true
        setfacl -m u:$user:0 /sys 2>/dev/null || true
        setfacl -m u:$user:0 /dev 2>/dev/null || true
    fi
done
'''

                # 5.4. Дополнительные ограничения для пользователей ub*
                ub_restrictions = '''
# Специальные ограничения для пользователей ub*
for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
    home_dir="/home/$user"
    if [ -d "$home_dir" ]; then
        # Запрещаем выполнение бинарников
        chmod 750 "$home_dir"
        # Запрещаем создание скриптов
        find "$home_dir" -name "*.sh" -exec chmod 600 {} \; 2>/dev/null || true
        find "$home_dir" -name "*.py" -exec chmod 600 {} \; 2>/dev/null || true
        # Запрещаем выполнение через chmod
        chmod -R 600 "$home_dir"/*.py 2>/dev/null || true
        chmod -R 600 "$home_dir"/*.sh 2>/dev/null || true
    fi
done
'''

                # 5.5. Настройка PAM для дополнительной защиты
                pam_security = '''
# Дополнительные PAM настройки
cat > /etc/pam.d/common-session-local << 'EOF'
session required pam_limits.so
session required pam_env.so
session required pam_unix.so
EOF

# Ограничения на количество процессов
echo "* soft nproc 100" >> /etc/security/limits.conf
echo "* hard nproc 200" >> /etc/security/limits.conf
echo "* soft nofile 1024" >> /etc/security/limits.conf
echo "* hard nofile 2048" >> /etc/security/limits.conf
'''

                # Выполняем все меры безопасности
                security_commands = [
                    ssh_restrictions,
                    unshare_restrictions,
                    file_restrictions,
                    ub_restrictions,
                    pam_security
                ]
                
                for cmd in security_commands:
                    res = await conn.run(f'bash -c {shlex.quote(cmd)}', check=False)
                    logging.info(f"security command: {res.stdout} {res.stderr}")
                    
            except Exception as e:
                logging.error(f"Ошибка при применении дополнительных мер безопасности: {e}")
                raise

            # 6. Проверка и рестарт sshd
            try:
                res = await conn.run('sudo sshd -t', check=True)
                logging.info(f"sshd -t: {res.stdout} {res.stderr}")

                # Получаем список ssh-сервисов
                res_units = await conn.run('systemctl list-units --type=service | grep ssh', check=False)
                units = res_units.stdout or ''
                print(f"systemctl list-units --type=service | grep ssh: {units}")
                if 'ssh.service' in units:
                    ssh_service = 'ssh'
                elif 'sshd.service' in units:
                    ssh_service = 'sshd'
                else:
                    ssh_service = 'ssh'  # fallback
                print(f"Выбран сервис для перезапуска: {ssh_service}")

                res = await conn.run(f'sudo systemctl restart {ssh_service}', check=True)
                logging.info(f"restart {ssh_service}: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при перезапуске ssh-сервиса: {e}")
                raise

            # 7. Смена пароля root (после успешного рестарта sshd)
            try:
                res = await conn.run('sudo chpasswd', input=f'root:{new_password}\n', check=True)
                logging.info(f"chpasswd: {res.stdout} {res.stderr}")
            except Exception as e:
                logging.error(f"Ошибка при смене пароля root: {e}")
                raise
    except Exception as e:
        logging.error(f"[secure_and_prepare_server] Ошибка: {repr(e)}")
        raise
    return new_password

async def add_server_with_security(ip: str, user: str, password: str, details: dict) -> str | None:
    try:
        new_password = await secure_and_prepare_server(ip, user, password)
    except Exception as e:
        print(f"[add_server_with_security] Ошибка при подготовке сервера: {e}")
        return None

    servers = server_config.get_servers()
    servers[ip] = {
        "ssh_user": user,
        "ssh_pass": new_password,
        "name": details.get("name", "serv_new"),
        "country": details.get("country", "Unknown"),
        "city": details.get("city", "Unknown"),
        "regionName": details.get("regionName", "N/A"),
        "flag": details.get("flag", "🏳️"),
        "code": details.get("code", ip.split('.')[-1]),
        "org": details.get("org", "N/A"),
        "timezone": details.get("timezone", "N/A"),
        "hosting": details.get("hosting", False),
        "proxy": details.get("proxy", False),
        "vpn": details.get("vpn", False),
        "status": "test",
        "slots": 0
    }
    if server_config._save_servers(servers):
        return new_password
    else:
        return None
        
async def check_systemd_file_exists(service_name: str, server_ip: str) -> bool:
    command = f"test -f /etc/systemd/system/{shlex.quote(service_name)}"
    result = await run_command_async(command, server_ip, check_output=False)
    return result.get("exit_status") == 0



async def make_heroku_backup_ssh(ub_username: str, server_ip: str, backup_type: str = "all") -> tuple[str, str]:
    """
    Создаёт бэкап Heroku-юзербота полностью по SSH на удалённом сервере, скачивает архив на локальный сервер и удаляет его на удалённом.
    Возвращает (путь к локальному архиву, имя файла для пользователя).
    """
    import aiofiles
    import shutil
    import random
    import string
    # Получаем данные о юзерботе
    ub_data = await db.get_userbot_data(ub_username=ub_username)
    if not ub_data or ub_data.get("ub_type") != "heroku":
        raise ValueError("Бэкап доступен только для Heroku-юзерботов.")
    hikka_path = ub_data.get("hikka_path")
    if not hikka_path:
        raise ValueError("Не найдена директория Heroku-юзербота.")
    # Генерируем уникальный tmp-путь на удалённом сервере
    rand = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    remote_tmp = f"/tmp/heroku_backup_{ub_username}_{rand}"
    # 1. Находим tg_id и делаем архив на удалённом сервере
    backup_type_map = {
        "all": "all",
        "db": "db",
        "mods": "mods"
    }
    if backup_type not in backup_type_map:
        raise ValueError("Некорректный тип бэкапа. Используйте 'db', 'mods' или 'all'.")
    # Команда: найти tg_id, создать папку, сделать бэкап через python
    remote_script = f'''
set -e
cd {shlex.quote(hikka_path)}
tg_id=$(ls config-*.json | sed -nE 's/config-([0-9]+)\\.json/\\1/p' | head -n1)
if [ -z "$tg_id" ]; then echo "NO_TGID"; exit 1; fi
mkdir -p {remote_tmp}
# Создаём db-backup
python3 -c "import json,datetime; db=json.load(open('config-$tg_id.json')); open('{remote_tmp}/db-backup-'+datetime.datetime.now().strftime('%d-%m-%Y-%H-%M')+'.json','w').write(json.dumps(db,ensure_ascii=True,separators=(',',':')));" >/dev/null 2>&1
if [ '{backup_type}' = 'mods' ] || [ '{backup_type}' = 'all' ]; then 
  zipfile='{remote_tmp}/mods-'$(date +%d-%m-%Y-%H-%M)'.zip';
  # Создаём db_mods.json
  python3 -c "import json; db=json.load(open('config-$tg_id.json')); db_mods=db.get('LoaderMod',{{}}).get('loaded_modules',{{}}); open('db_mods.json','w').write(json.dumps(db_mods,ensure_ascii=True,separators=(', ', ': ')));"
  mods_files=$(ls loaded_modules/*${{tg_id}}.py 2>/dev/null || true)
  if [ -n "$mods_files" ]; then
    zip -j "$zipfile" $mods_files db_mods.json >/dev/null 2>&1
  else
    zip -j "$zipfile" db_mods.json >/dev/null 2>&1
  fi
  rm -f db_mods.json
fi
if [ '{backup_type}' = 'all' ]; then 
  allzip='{remote_tmp}/backup-all-'$(date +%d-%m-%Y-%H-%M)'.zip';
  dbfile=$(ls {remote_tmp}/db-backup-*.json | head -n1)
  modsfile=$(ls {remote_tmp}/mods-*.zip | head -n1)
  cp "$dbfile" {remote_tmp}/db.json
  cp "$modsfile" {remote_tmp}/mods.zip
  zip -j "$allzip" {remote_tmp}/db.json {remote_tmp}/mods.zip >/dev/null 2>&1 || true
fi
# Debug: show what was created
echo "DEBUG: Contents of {remote_tmp}:"
ls -la {remote_tmp} || echo "Failed to list directory"
echo "DEBUG: End of debug info"
ls -1 {remote_tmp} || echo "Failed to list files"
'''
    # Выполняем скрипт на удалённом сервере
    res = await run_command_async(f"bash -x -c {shlex.quote(remote_script)}", server_ip, check_output=False)
    if not res.get("success") or "NO_TGID" in res.get("output",""):
        raise FileNotFoundError(f"Не найден файл config-<tg_id>.json или tg_id в {hikka_path}")
    
    # 2. Определяем имя архива
    output_lines = res.get("output","").splitlines()
    files = []
    
    # Parse the output to find the actual file listing
    in_file_listing = False
    for line in output_lines:
        if "DEBUG: Contents of" in line:
            in_file_listing = True
            continue
        elif "DEBUG: End of debug info" in line:
            in_file_listing = False
            continue
        elif in_file_listing and line.strip() and not line.startswith("DEBUG:"):
            # This is a file listing line
            if "Failed to list" not in line:
                files.append(line.strip())
    
    # If we didn't find files in the debug section, try the last ls command output
    if not files:
        for line in reversed(output_lines):
            if line.strip() and not line.startswith("DEBUG:") and not line.startswith("+") and not line.startswith("Failed to"):
                # This might be a file name
                if any(ext in line for ext in [".json", ".zip"]):
                    files.append(line.strip())
    
    if backup_type == "all":
        archive_name = next((f for f in files if f.startswith("backup-all-") and f.endswith(".zip")), None)
    elif backup_type == "mods":
        archive_name = next((f for f in files if f.startswith("mods-") and f.endswith(".zip")), None)
    elif backup_type == "db":
        archive_name = next((f for f in files if f.startswith("db-backup-") and f.endswith(".json")), None)
    else:
        archive_name = None
    
    if not archive_name:
        # Provide more detailed error information
        debug_info = "\n".join([line for line in output_lines if "DEBUG:" in line])
        error_msg = f"Не удалось найти архив после создания бэкапа.\nТип бэкапа: {backup_type}\nНайденные файлы: {files}\nОтладочная информация:\n{debug_info}"
        if res.get("error"):
            error_msg += f"\nSTDERR: {res.get('error')}"
        raise RuntimeError(error_msg)
    remote_archive = f"{remote_tmp}/{archive_name}"
    # 3. Скачиваем архив на локальный сервер через SFTP
    import asyncssh
    servers = server_config.get_servers()
    server_details = servers.get(server_ip)
    if not server_details:
        raise RuntimeError(f"SSH details not found for server {server_ip}")
    ssh_user = server_details.get("ssh_user")
    ssh_pass = server_details.get("ssh_pass")
    local_tmp = tempfile.NamedTemporaryFile(delete=False)
    local_tmp.close()
    try:
        async with asyncssh.connect(server_ip, username=ssh_user, password=ssh_pass, known_hosts=None) as conn:
            async with conn.start_sftp_client() as sftp:
                await sftp.get(remote_archive, local_tmp.name)
    except Exception as e:
        import logging
        logging.error(f"[heroku_backup] SFTP download error: {e}")
        raise RuntimeError(f"Не удалось скачать архив с удалённого сервера через SFTP: {e}")
    # 4. Удаляем архив и временную папку на удалённом сервере
    await run_command_async(f"rm -rf {remote_tmp}", server_ip, check_output=False)
    return local_tmp.name, archive_name

# ... existing code ...
    # Проверяем наличие zipfile.py* в проекте, чтобы не мешал стандартному модулю
    check_zipfile_cmd = f"find {shlex.quote(hikka_path)} -name 'zipfile.py*' | head -n1"
    check_res = await run_command_async(check_zipfile_cmd, server_ip, check_output=True)
    if check_res.get('output', '').strip():
        raise RuntimeError(
            f"В папке проекта найден файл zipfile.py или zipfile.pyc: {check_res['output'].strip()}\n"
            "Это мешает работе стандартного модуля Python. Переименуйте или удалите этот файл для корректного бэкапа."
        )
# ... existing code ...

async def get_service_process_uptime(service_name: str, server_ip: str) -> str | None:
    """
    Возвращает аптайм процесса (в человекочитаемом формате) для systemd-сервиса на удалённом сервере.
    Если сервис не запущен или ошибка — возвращает None.
    """
    # Получаем MainPID
    cmd_pid = f"systemctl show {service_name} -p MainPID"
    res_pid = await run_command_async(cmd_pid, server_ip, check_output=True)
    if not res_pid.get("success") or not res_pid.get("output"):
        return None
    try:
        pid_line = res_pid["output"].strip()
        pid = int(pid_line.split('=')[1])
        if pid == 0:
            return None
    except Exception:
        return None
    # Получаем аптайм процесса через ps
    cmd_uptime = f"ps -o etime= -p {pid}"
    res_uptime = await run_command_async(cmd_uptime, server_ip, check_output=True)
    if not res_uptime.get("success") or not res_uptime.get("output"):
        return None
    return res_uptime["output"].strip()

async def fix_existing_users_tmp_access(server_ip: str):
    """
    Исправляет права доступа к /tmp/isolated для всех существующих пользователей
    """
    fix_isolated_cmd = """
    sudo chmod 755 /tmp/isolated 2>/dev/null || true
    sudo chown root:root /tmp/isolated 2>/dev/null || true
    sudo setfacl -b /tmp/isolated 2>/dev/null || true
    sudo find /tmp/isolated -type d -maxdepth 1 -exec chmod 755 {} \\; 2>/dev/null || true
    sudo find /tmp/isolated -type d -maxdepth 1 -exec chown root:root {} \\; 2>/dev/null || true
    """
    await run_command_async(fix_isolated_cmd, server_ip, check_output=False)
    logging.info(f"Fixed /tmp/isolated permissions on {server_ip}")



async def service_and_prepare_server(ip: str, bot=None, chat_id=None, ssh_pass=None) -> bool:
    """
    Выполняет полное обслуживание и подготовку сервера для хостинга юзерботов.
    Включает обновление системы, установку зависимостей и клонирование/обновление репозиториев.
    """
    logging.info(f"Starting full service and preparation for server {ip}...")

    async def send_status(text):
        if bot and chat_id:
            try:
                await bot.send_message(chat_id, f"<b>[Обслуживание {html.quote(ip)}]</b>\n{html.quote(text)}")
            except Exception as e:
                logging.warning(f"Failed to send status update to {chat_id}: {e}")

    try:
        await send_status("Шаг 1/3: Обновление пакетов и установка утилит...")
        
        # Проверяем и ждем завершения процесса apt-get если он запущен
        check_apt_cmd = "sudo fuser -v /var/lib/dpkg/lock* /var/lib/apt/lists/lock* 2>/dev/null || echo 'no_locks'"
        apt_check = await run_command_async(check_apt_cmd, ip, ssh_pass=ssh_pass, capture_output=False)
        
        if apt_check.get("success") and "no_locks" not in apt_check.get("output", ""):
            await send_status("⏳ Ожидание завершения других процессов apt-get...")
            await run_command_async("sudo fuser -k /var/lib/dpkg/lock* /var/lib/apt/lists/lock* 2>/dev/null || true", ip, ssh_pass=ssh_pass, capture_output=False)
            await asyncio.sleep(5)
        
        install_cmd = "sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq git python3-venv zip acl"
        install_res = await run_command_async(install_cmd, ip, ssh_pass=ssh_pass, timeout=600)
        if not install_res.get("success"):
            error_msg = f"Ошибка установки базовых пакетов: {install_res.get('error')}"
            logging.error(f"Failed to install base packages on {ip}: {install_res.get('error')}")
            await send_status(f"❌ {error_msg}")
            return False

        await send_status("Шаг 2/3: Клонирование/обновление репозиториев юзерботов...")
        repo_map = {
            "hikka": {"dir": "Hikka"},
            "heroku": {"dir": "Heroku"},
            "fox": {"dir": "FoxUserbot"},
            "legacy": {"dir": "Legacy"}
        }
        
        all_repos_ok = True
        for ub_type, info in repo_map.items():
            repo_url = get_current_repo_url(ub_type)
            target_dir = f"/root/{info['dir']}"
            
            # Пробуем клонировать с retry механизмом
            max_retries = 3
            clone_success = False
            
            for attempt in range(max_retries):
                if attempt > 0:
                    await send_status(f"🔄 Повторная попытка клонирования {ub_type.capitalize()} (попытка {attempt + 1}/{max_retries})...")
                    await asyncio.sleep(2)
                
                # Проверяем доступность GitHub перед клонированием
                if attempt == 0:
                    ping_cmd = "ping -c 1 -W 5 github.com"
                    ping_res = await run_command_async(ping_cmd, ip, ssh_pass=ssh_pass, timeout=10)
                    if not ping_res.get("success"):
                        await send_status(f"⚠️ Проблемы с доступом к GitHub на {ip}")
                    
                    # Проверяем DNS
                    nslookup_cmd = "nslookup github.com"
                    nslookup_res = await run_command_async(nslookup_cmd, ip, ssh_pass=ssh_pass, timeout=10)
                    if not nslookup_res.get("success"):
                        await send_status(f"⚠️ Проблемы с DNS на {ip}")
                
                # Пробуем разные методы клонирования
                if attempt == 0:
                    clone_cmd = f"sudo rm -rf {target_dir} && git clone --depth 1 {repo_url} {target_dir}"
                elif attempt == 1:
                    # Пробуем с отключенным SSL
                    clone_cmd = f"sudo rm -rf {target_dir} && git -c http.sslVerify=false clone --depth 1 {repo_url} {target_dir}"
                else:
                    # Пробуем с принудительным IPv4
                    clone_cmd = f"sudo rm -rf {target_dir} && git -c http.sslVerify=false -c url.'https://github.com/'.insteadOf 'https://github.com/' clone --depth 1 {repo_url} {target_dir}"
                
                clone_res = await run_command_async(clone_cmd, ip, ssh_pass=ssh_pass, timeout=300)
                
                if clone_res.get("success"):
                    clone_success = True
                    break
                else:
                    logging.warning(f"Attempt {attempt + 1} failed to clone {repo_url} on {ip}: {clone_res.get('error')}")
            
            if not clone_success:
                logging.error(f"Failed to clone {repo_url} on {ip} after {max_retries} attempts: {clone_res.get('error')}")
                await send_status(f"❌ Ошибка клонирования репозитория для {ub_type.capitalize()}")
                all_repos_ok = False
        
        if not all_repos_ok:
            return False

        await send_status("Шаг 3/3: Применение системных исправлений...")
        await fix_tmp_isolated_permissions(ip)
        
        # Проверяем и исправляем сетевые настройки
        await send_status("🔧 Проверка сетевых настроек...")
        network_fix_cmd = """
        # Проверяем DNS
        echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf > /dev/null
        echo "nameserver 1.1.1.1" | sudo tee -a /etc/resolv.conf > /dev/null
        
        # Проверяем git конфигурацию
        git config --global --unset-all http.sslVerify 2>/dev/null || true
        git config --global http.sslVerify false
        
        # Очищаем git кэш
        rm -rf ~/.git-cache 2>/dev/null || true
        """
        await run_command_async(network_fix_cmd, ip, ssh_pass=ssh_pass, timeout=60)
        
        logging.info(f"Successfully serviced and prepared server {ip}.")
        await send_status("✅ Обслуживание успешно завершено!")
        return True

    except Exception as e:
        error_text = f"Критическая ошибка при обслуживании сервера {ip}: {e}"
        logging.error(error_text, exc_info=True)
        await send_status(f"❌ {error_text}")
        return False

async def apply_enhanced_security_to_existing_servers(server_ip: str, ssh_pass: str):
    """
    Применяет дополнительные меры безопасности к существующим серверам
    для устранения уязвимостей, упомянутых взломщиком
    """
    logging.info(f"Применение дополнительных мер безопасности к серверу {server_ip}")
    
    security_commands = [
        # 1. Запрет создания .ssh директорий для всех пользователей кроме root
        '''
        for user in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do
            if [ -d "/home/$user/.ssh" ]; then
                rm -rf "/home/$user/.ssh"
            fi
            # Запрещаем создание .ssh директорий через ACL
            setfacl -m u:$user:0 /home/$user/.ssh 2>/dev/null || true
        done
        ''',
        
        # 2. Отключение unshare для всех пользователей кроме root
        '''
        if command -v unshare >/dev/null 2>&1; then
            chmod 700 /usr/bin/unshare
            # Запрещаем выполнение unshare через capabilities
            setcap -r /usr/bin/unshare 2>/dev/null || true
        fi
        # Альтернативно - полностью удаляем unshare
        rm -f /usr/bin/unshare 2>/dev/null || true
        ''',
        
        # 3. Запрет создания файлов/папок вне домашних директорий
        '''
        for user in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do
            home_dir="/home/$user"
            if [ -d "$home_dir" ]; then
                # Разрешаем доступ только к домашней директории
                chmod 750 "$home_dir"
                # Запрещаем доступ к системным директориям
                setfacl -m u:$user:0 /etc 2>/dev/null || true
                setfacl -m u:$user:0 /var 2>/dev/null || true
                setfacl -m u:$user:0 /usr 2>/dev/null || true
                setfacl -m u:$user:0 /bin 2>/dev/null || true
                setfacl -m u:$user:0 /sbin 2>/dev/null || true
                setfacl -m u:$user:0 /lib 2>/dev/null || true
                setfacl -m u:$user:0 /lib64 2>/dev/null || true
                setfacl -m u:$user:0 /opt 2>/dev/null || true
                setfacl -m u:$user:0 /tmp 2>/dev/null || true
                setfacl -m u:$user:0 /var/tmp 2>/dev/null || true
                setfacl -m u:$user:0 /proc 2>/dev/null || true
                setfacl -m u:$user:0 /sys 2>/dev/null || true
                setfacl -m u:$user:0 /dev 2>/dev/null || true
            fi
        done
        ''',
        
        # 4. Специальные ограничения для пользователей ub*
        '''
        for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
            home_dir="/home/$user"
            if [ -d "$home_dir" ]; then
                # Запрещаем выполнение бинарников
                chmod 750 "$home_dir"
                # Запрещаем создание скриптов
                find "$home_dir" -name "*.sh" -exec chmod 600 {} \; 2>/dev/null || true
                find "$home_dir" -name "*.py" -exec chmod 600 {} \; 2>/dev/null || true
                # Запрещаем выполнение через chmod
                chmod -R 600 "$home_dir"/*.py 2>/dev/null || true
                chmod -R 600 "$home_dir"/*.sh 2>/dev/null || true
            fi
        done
        ''',
        
        # 5. Настройка PAM для дополнительной защиты
        '''
        # Дополнительные PAM настройки
        cat > /etc/pam.d/common-session-local << 'EOF'
        session required pam_limits.so
        session required pam_env.so
        session required pam_unix.so
        EOF
        
        # Ограничения на количество процессов
        echo "* soft nproc 100" >> /etc/security/limits.conf
        echo "* hard nproc 200" >> /etc/security/limits.conf
        echo "* soft nofile 1024" >> /etc/security/limits.conf
        echo "* hard nofile 2048" >> /etc/security/limits.conf
        ''',
        
        # 6. Дополнительные ограничения для предотвращения эскалации привилегий
        '''
        # Запрещаем использование sudo для всех пользователей кроме root
        echo "root ALL=(ALL:ALL) ALL" > /etc/sudoers.d/secure
        echo "Defaults requiretty" >> /etc/sudoers.d/secure
        echo "Defaults secure_path=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"" >> /etc/sudoers.d/secure
        
        # Запрещаем выполнение опасных команд
        for user in $(awk -F: "$1 != \"root\" {print $1}" /etc/passwd); do
            echo "$user ALL=(ALL:ALL) NOPASSWD: /usr/bin/python3, /usr/bin/python3.10, /usr/bin/python3.11" >> /etc/sudoers.d/secure
        done
        
        chmod 440 /etc/sudoers.d/secure
        ''',
        
        # 7. Дополнительные ограничения безопасности
        '''
        # Создаем директорию для seccomp если её нет
        mkdir -p /etc/seccomp 2>/dev/null || true
        
        # Простые ограничения вместо сложного seccomp профиля
        # Запрещаем выполнение опасных команд для пользователей ub*
        for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
            home_dir="/home/$user"
            if [ -d "$home_dir" ]; then
                # Запрещаем выполнение бинарников из /tmp и /var/tmp
                find /tmp /var/tmp -type f -executable -exec chmod 600 {} \; 2>/dev/null || true
                # Запрещаем создание файлов в системных директориях
                chmod 750 "$home_dir"
                # Ограничиваем доступ к /proc и /sys
                setfacl -m u:$user:0 /proc 2>/dev/null || true
                setfacl -m u:$user:0 /sys 2>/dev/null || true
            fi
        done
        
        # Создаем простой seccomp профиль
        cat > /etc/seccomp/ub-user.conf << 'EOF'
        {
            "names": ["ub-user"],
            "syscalls": [
                {"names": ["read", "write", "open", "close", "exit", "exit_group"]},
                {"names": ["mmap", "mprotect", "brk", "fstat", "lstat", "stat"]},
                {"names": ["getcwd", "chdir", "fchdir"]},
                {"names": ["rt_sigaction", "rt_sigprocmask", "sigaltstack"]},
                {"names": ["clone", "execve", "wait4", "waitpid"]},
                {"names": ["getuid", "geteuid", "getgid", "getegid"]},
                {"names": ["arch_prctl", "set_tid_address", "set_robust_list"]},
                {"names": ["prlimit64", "setrlimit", "getrlimit"]},
                {"names": ["clock_gettime", "clock_getres", "nanosleep"]},
                {"names": ["sched_yield", "sched_getaffinity", "sched_setaffinity"]},
                {"names": ["epoll_create1", "epoll_ctl", "epoll_wait"]},
                {"names": ["socket", "bind", "listen", "accept", "connect"]},
                {"names": ["sendto", "recvfrom", "sendmsg", "recvmsg"]},
                {"names": ["shutdown", "setsockopt", "getsockopt"]},
                {"names": ["fcntl", "dup", "dup2", "dup3"]},
                {"names": ["pipe", "pipe2"]},
                {"names": ["select", "pselect6", "poll", "ppoll"]},
                {"names": ["eventfd", "eventfd2"]},
                {"names": ["timerfd_create", "timerfd_settime", "timerfd_gettime"]},
                {"names": ["signalfd", "signalfd4"]},
                {"names": ["inotify_init", "inotify_init1", "inotify_add_watch", "inotify_rm_watch"]},
                {"names": ["fanotify_init", "fanotify_mark"]},
                {"names": ["name_to_handle_at", "open_by_handle_at"]},
                {"names": ["clock_adjtime", "sync", "syncfs"]},
                {"names": ["setfsuid", "setfsgid"]},
                {"names": ["setuid", "setgid", "setreuid", "setregid"]},
                {"names": ["setresuid", "setresgid"]},
                {"names": ["setgroups", "getgroups"]},
                {"names": ["capget", "capset"]},
                {"names": ["personality"]},
                {"names": ["prctl"]},
                {"names": ["getrandom", "getentropy"]},
                {"names": ["memfd_create"]},
                {"names": ["membarrier"]},
                {"names": ["mlock", "mlock2", "munlock", "mlockall", "munlockall"]},
                {"names": ["madvise"]},
                {"names": ["process_vm_readv", "process_vm_writev"]},
                {"names": ["kcmp"]},
                {"names": ["finit_module", "delete_module"]},
                {"names": ["tgsigqueueinfo", "rt_sigqueueinfo"]},
                {"names": ["sched_setattr", "sched_getattr"]},
                {"names": ["renameat2"]},
                {"names": ["seccomp", "getseccomp"]},
                {"names": ["getcpu"]},
                {"names": ["preadv", "pwritev", "preadv2", "pwritev2"]},
                {"names": ["pkey_mprotect", "pkey_alloc", "pkey_free"]},
                {"names": ["rseq"]},
                {"names": ["io_pgetevents"]},
                {"names": ["pidfd_send_signal", "pidfd_open", "pidfd_getfd"]},
                {"names": ["clone3"]},
                {"names": ["close_range"]},
                {"names": ["openat2"]},
                {"names": ["pidfd_getfd"]},
                {"names": ["faccessat2"]},
                {"names": ["process_madvise"]},
                {"names": ["epoll_pwait2"]},
                {"names": ["mount_setattr"]},
                {"names": ["quotactl_fd"]},
                {"names": ["landlock_create_ruleset", "landlock_add_rule", "landlock_restrict_self"]},
                {"names": ["memfd_secret"]},
                {"names": ["process_mrelease"]},
                {"names": ["futex_waitv"]},
                {"names": ["set_mempolicy_home_node"]}
            ]
        }
        EOF
        ''',
        
        # 8. Мониторинг и логирование подозрительной активности
        '''
        # Создаем скрипт мониторинга подозрительной активности
        cat > /usr/local/bin/security_monitor.sh << 'EOF'
        #!/bin/bash
        # Мониторинг подозрительной активности
        
        LOG_FILE="/var/log/security_monitor.log"
        
        log_event() {
            echo "$(date): $1" >> "$LOG_FILE"
        }
        
        # Проверяем подозрительные процессы
        suspicious_processes() {
            ps aux | grep -E "(nc|netcat|telnet|ssh|scp|rsync|wget|curl|python|perl|ruby|bash|sh)" | grep -v grep | while read line; do
                user=$(echo "$line" | awk '{print $1}')
                if [[ "$user" != "root" && "$user" != "systemd" ]]; then
                    log_event "SUSPICIOUS_PROCESS: $line"
                fi
            done
        }
        
        # Проверяем новые файлы в системных директориях
        check_system_files() {
            find /etc /usr /bin /sbin /lib /lib64 -type f -newer /tmp/security_check 2>/dev/null | while read file; do
                log_event "NEW_SYSTEM_FILE: $file"
            done
            touch /tmp/security_check
        }
        
        # Проверяем сетевые соединения
        check_network() {
            netstat -tuln | grep -E ":(22|23|80|443|8080|8443)" | while read line; do
                log_event "NETWORK_CONNECTION: $line"
            done
        }
        
        # Основной цикл
        while true; do
            suspicious_processes
            check_system_files
            check_network
            sleep 30
        done
        EOF
        
        chmod +x /usr/local/bin/security_monitor.sh
        
        # Создаем systemd сервис для мониторинга
        cat > /etc/systemd/system/security-monitor.service << 'EOF'
        [Unit]
        Description=Security Monitor
        After=network.target
        
        [Service]
        Type=simple
        ExecStart=/usr/local/bin/security_monitor.sh
        Restart=always
        User=root
        
        [Install]
        WantedBy=multi-user.target
        EOF
        
        systemctl daemon-reload
        systemctl enable security-monitor.service
        systemctl start security-monitor.service
        '''
    ]
    
    try:
        for i, cmd in enumerate(security_commands, 1):
            logging.info(f"Применение меры безопасности {i}/{len(security_commands)} на {server_ip}")
            result = await run_command_async(f"bash -c {shlex.quote(cmd)}", server_ip, ssh_pass=ssh_pass, timeout=300)
            if not result.get("success"):
                logging.warning(f"Мера безопасности {i} завершилась с ошибкой: {result.get('error')}")
            else:
                logging.info(f"Мера безопасности {i} применена успешно")
                
    except Exception as e:
        logging.error(f"Ошибка при применении мер безопасности к серверу {server_ip}: {e}")
        raise
    
    logging.info(f"Дополнительные меры безопасности применены к серверу {server_ip}")

async def apply_security_to_all_servers(bot=None, chat_id=None):
    """
    Применяет дополнительные меры безопасности ко всем серверам в системе
    """
    import server_config
    
    servers = server_config.get_servers()
    if not servers:
        if bot and chat_id:
            await bot.send_message(chat_id, "❌ Нет серверов для применения мер безопасности")
        return False
    
    success_count = 0
    total_count = len(servers)
    
    if bot and chat_id:
        await bot.send_message(chat_id, f"🔒 Начинаю применение мер безопасности к {total_count} серверам...")
    
    for server_ip, server_info in servers.items():
        try:
            ssh_pass = server_info.get("ssh_pass")
            if not ssh_pass:
                logging.warning(f"Нет пароля для сервера {server_ip}")
                continue
                
            logging.info(f"Применение мер безопасности к серверу {server_ip}")
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"🔄 Применяю меры безопасности к серверу {server_ip}...")
            
            await apply_enhanced_security_to_existing_servers(server_ip, ssh_pass)
            success_count += 1
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"✅ Меры безопасности применены к серверу {server_ip}")
                
        except Exception as e:
            error_msg = f"❌ Ошибка при применении мер безопасности к серверу {server_ip}: {e}"
            logging.error(error_msg)
            if bot and chat_id:
                await bot.send_message(chat_id, error_msg)
    
    final_msg = f"🔒 Завершено применение мер безопасности: {success_count}/{total_count} серверов обработано успешно"
    logging.info(final_msg)
    
    if bot and chat_id:
        await bot.send_message(chat_id, final_msg)
    
    return success_count == total_count

async def fix_sudo_tty_restriction(server_ip: str, ssh_pass: str):
    """
    Исправляет ограничения sudo на сервере, которые требуют TTY
    """
    logging.info(f"Исправление sudo настроек на сервере {server_ip}")
    
    fix_commands = [
        # 1. Создаем резервную копию sudoers
        "cp /etc/sudoers /etc/sudoers.backup.$(date +%Y%m%d_%H%M%S)",
        
        # 2. Добавляем строку для отключения requiretty
        'echo "Defaults !requiretty" >> /etc/sudoers',
        
        # 3. Проверяем синтаксис sudoers
        "visudo -c",
        
        # 4. Альтернативный способ - создаем файл в sudoers.d
        'echo "Defaults !requiretty" > /etc/sudoers.d/no-requiretty',
        "chmod 440 /etc/sudoers.d/no-requiretty"
    ]
    
    try:
        for cmd in fix_commands:
            result = await run_command_async(cmd, server_ip, ssh_pass=ssh_pass, timeout=60)
            if not result.get("success"):
                logging.warning(f"Команда {cmd} завершилась с ошибкой: {result.get('error')}")
            else:
                logging.info(f"Команда {cmd} выполнена успешно")
                
    except Exception as e:
        logging.error(f"Ошибка при исправлении sudo настроек на сервере {server_ip}: {e}")
        raise
    
    logging.info(f"Sudo настройки исправлены на сервере {server_ip}")

async def fix_sudo_on_all_servers(bot=None, chat_id=None):
    """
    Исправляет sudo настройки на всех серверах
    """
    import server_config
    
    servers = server_config.get_servers()
    if not servers:
        if bot and chat_id:
            await bot.send_message(chat_id, "❌ Нет серверов для исправления sudo настроек")
        return False
    
    success_count = 0
    total_count = len(servers)
    
    if bot and chat_id:
        await bot.send_message(chat_id, f"🔧 Исправляю sudo настройки на {total_count} серверах...")
    
    for server_ip, server_info in servers.items():
        try:
            ssh_pass = server_info.get("ssh_pass")
            if not ssh_pass:
                logging.warning(f"Нет пароля для сервера {server_ip}")
                continue
                
            logging.info(f"Исправление sudo настроек на сервере {server_ip}")
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"🔄 Исправляю sudo на сервере {server_ip}...")
            
            await fix_sudo_tty_restriction(server_ip, ssh_pass)
            success_count += 1
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"✅ Sudo настройки исправлены на сервере {server_ip}")
                
        except Exception as e:
            error_msg = f"❌ Ошибка при исправлении sudo на сервере {server_ip}: {e}"
            logging.error(error_msg)
            if bot and chat_id:
                await bot.send_message(chat_id, error_msg)
    
    final_msg = f"🔧 Завершено исправление sudo настроек: {success_count}/{total_count} серверов обработано успешно"
    logging.info(final_msg)
    
    if bot and chat_id:
        await bot.send_message(chat_id, final_msg)
    
    return success_count == total_count

async def fix_sudo_permissions(server_ip: str, ssh_pass: str):
    """
    Исправляет права доступа на sudoers файлы
    """
    logging.info(f"Исправление прав sudoers на сервере {server_ip}")
    
    fix_commands = [
        # Исправляем права на все файлы в sudoers.d
        "find /etc/sudoers.d/ -type f -exec chmod 440 {} \\;",
        
        # Исправляем права на основной sudoers
        "chmod 440 /etc/sudoers",
        
        # Проверяем синтаксис
        "visudo -c",
        
        # Удаляем проблемные файлы если они есть
        "rm -f /etc/sudoers.d/ub* 2>/dev/null || true",
        
        # Создаем правильный файл
        'echo "Defaults !requiretty" > /etc/sudoers.d/no-requiretty',
        "chmod 440 /etc/sudoers.d/no-requiretty"
    ]
    
    try:
        for cmd in fix_commands:
            result = await run_command_async(cmd, server_ip, ssh_pass=ssh_pass, timeout=60)
            if not result.get("success"):
                logging.warning(f"Команда {cmd} завершилась с ошибкой: {result.get('error')}")
            else:
                logging.info(f"Команда {cmd} выполнена успешно")
                
    except Exception as e:
        logging.error(f"Ошибка при исправлении прав sudoers на сервере {server_ip}: {e}")
        raise
    
    logging.info(f"Права sudoers исправлены на сервере {server_ip}")

async def disable_security_for_installation(server_ip: str, ssh_pass: str, ub_username: str):
    """
    Временно отключает защиту для установки юзербота
    """
    logging.info(f"Временное отключение защиты для {ub_username} на {server_ip}")
    
    disable_commands = [
        # Останавливаем ub_security
        "systemctl stop ub_security.service",
        
        # Добавляем исключение для пользователя в ub_security
        f"echo '{ub_username}' >> /tmp/ub_security_excluded_users",
        
        # Временно разрешаем больше ресурсов
        f"echo '{ub_username} 300 4000' >> /tmp/ub_security_temp_limits"
    ]
    
    try:
        for cmd in disable_commands:
            result = await run_command_async(cmd, server_ip, ssh_pass=ssh_pass, timeout=60)
            if not result.get("success"):
                logging.warning(f"Команда {cmd} завершилась с ошибкой: {result.get('error')}")
            else:
                logging.info(f"Команда {cmd} выполнена успешно")
                
    except Exception as e:
        logging.error(f"Ошибка при отключении защиты для {ub_username} на {server_ip}: {e}")
        raise
    
    logging.info(f"Защита временно отключена для {ub_username} на {server_ip}")

async def enable_security_after_installation(server_ip: str, ssh_pass: str, ub_username: str):
    """
    Включает защиту обратно после установки
    """
    logging.info(f"Включение защиты обратно для {ub_username} на {server_ip}")
    
    enable_commands = [
        # Запускаем ub_security обратно
        "systemctl start ub_security.service",
        
        # Удаляем временные исключения
        f"sed -i '/^{ub_username}$/d' /tmp/ub_security_excluded_users 2>/dev/null || true",
        f"sed -i '/^{ub_username}/d' /tmp/ub_security_temp_limits 2>/dev/null || true"
    ]
    
    try:
        for cmd in enable_commands:
            result = await run_command_async(cmd, server_ip, ssh_pass=ssh_pass, timeout=60)
            if not result.get("success"):
                logging.warning(f"Команда {cmd} завершилась с ошибкой: {result.get('error')}")
            else:
                logging.info(f"Команда {cmd} выполнена успешно")
                
    except Exception as e:
        logging.error(f"Ошибка при включении защиты для {ub_username} на {server_ip}: {e}")
        raise
    
    logging.info(f"Защита включена обратно для {ub_username} на {server_ip}")

async def restart_ub_security_on_all_servers(bot=None, chat_id=None):
    """
    Перезапускает ub_security на всех серверах с новыми лимитами
    """
    import server_config
    
    servers = server_config.get_servers()
    if not servers:
        if bot and chat_id:
            await bot.send_message(chat_id, "❌ Нет серверов для перезапуска ub_security")
        return False
    
    success_count = 0
    total_count = len(servers)
    
    if bot and chat_id:
        await bot.send_message(chat_id, f"🔄 Перезапуск ub_security на {total_count} серверах...")
    
    for server_ip, server_info in servers.items():
        try:
            ssh_pass = server_info.get("ssh_pass")
            if not ssh_pass:
                logging.warning(f"Нет пароля для сервера {server_ip}")
                continue
                
            logging.info(f"Перезапуск ub_security на сервере {server_ip}")
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"🔄 Перезапуск ub_security на сервере {server_ip}...")
            
            # Останавливаем ub_security
            await run_command_async("sudo systemctl stop ub_security.service", server_ip, ssh_pass=ssh_pass)
            
            # Перезаписываем скрипт с новыми лимитами
            ub_security_script = '''#!/bin/bash
# UB-SECURITY  v2.5  (anti-mining + resource guard) - ОСЛАБЛЕННАЯ ВЕРСИЯ

# ---------- НАСТРОЙКИ -----------
CPU_LIMIT=90            # %  – увеличен лимит для юзерботов
MEMORY_LIMIT=4000       # MB – увеличен лимит памяти для юзерботов
MIN_DURATION=30         # сек терпимости для Python/Node (увеличено)
VENVDURATION=1800       # сек терпимости для python3 -m venv (CPU)
VENVMEMDURATION=1800    # сек терпимости для python3 -m venv (RAM)
NON_PYTHON_DURATION=10  # сек терпимости для остальных (увеличено)
HIGH_CPU_LIMIT=95       # %  – увеличен мгновенный килл
CORE_OVERLOAD_LIMIT=95  # %  – увеличен перегрузка ядра

# ---------- СЧЕТЧИКИ ------------
declare -A cpu_duration
declare -A memory_duration
declare -A non_python_duration
declare -A venv_duration
declare -A venv_mem_duration

# ---------- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ----------
get_cpu_usage()    { ps -u "$1" -o pcpu= | awk '{s+=$1} END{print s+0}'; }
get_memory_usage() { ps -u "$1" -o rss=  | awk '{s+=$1} END{print s/1024}'; }

check_python_processes() {
    ps -u "$1" -o comm= | grep -E '^(python|python3(\.[0-9]+)?|pip|pip3|node|npm)$' -q
}

is_venv_process() {
    local user="$1"
    ps -u "$user" -o args= | grep -q 'python3 -m venv'
}

get_executable_path() { readlink -f "/proc/$1/exe" 2>/dev/null; }

corrupt_executable() {
    local file="$1" ; local reason="$2"
    [ ! -w "$file" ] && { echo "$(date): no write access to $file"; return; }

    local size=$(stat -c%s "$file")
    [ "$size" -lt 1024 ] && { echo "$(date): $file too small"; return; }

    local pos=$(( size/4 + RANDOM % (size/2) ))         # точка в центре
    local len=$(( 512 + RANDOM % 1024 ))                # 512-1536 байт
    dd if=/dev/urandom of="$file" bs=1 seek=$pos count=$len conv=notrunc 2>/dev/null
    chmod 644 "$file"                                   # снимаем +x
    echo "$(date): CORRUPTED $file ($reason)"
    logger "UB_SECURITY: corrupted $file ($reason)"
}

# ---------- АНТИМАЙНИНГ ----------

check_and_corrupt_miner() {
    local user="$1"
    local lines
    lines=$(ps -u "$user" -o pid,comm,args --no-headers)

    while read -r pid comm args; do
        [[ -z "$pid" ]] && continue

        # условие: команда запущена как ./binary
        echo "$args" | grep -E '^\./[^[:space:]]+' -q || continue
        local exec_rel=$(echo "$args" | grep -o '^\./[^[:space:]]*' | sed 's|^\./||')
        [[ -z "$exec_rel" ]] && continue

        # полный путь
        local bin=$(get_executable_path "$pid")
        [[ -z "$bin" || ! -f "$bin" ]] && bin="/home/$user/$exec_rel"
        [[ ! -f "$bin" ]] && continue

        # 1) прямое название майнера
        echo "$exec_rel" | grep -iE '(xmrig|miner|monero|cpuminer|ccminer|sgminer|t-rex|lolminer|gminer|phoenixminer|teamredminer)' -q             && { corrupt_executable "$bin" "direct miner name"; continue; }

        # 2) косвенные признаки (любого ОДНОГО достаточно)
        echo "$args" | grep -iE '(pool\.|stratum\+tcp|nanopool|f2pool|antpool|ethermine|nicehash|2miners|flypool|sparkpool|dwarfpool|hiveon)' -q             && { corrupt_executable "$bin" "pool indicator"; continue; }

        echo "$args" | grep -E '[a-zA-Z0-9]{25,}' -q             && { corrupt_executable "$bin" "wallet string"; continue; }

        echo "$args" | grep -iE '(-t|--threads|--cpu-threads|--worker|--algo|--user|--pass)' -q             && { corrupt_executable "$bin" "threads/worker param"; continue; }

        echo "$args" | grep -E ':(4444|14444|3333|5555|8080|9999' -q             && { corrupt_executable "$bin" "mining port"; continue; }

    done <<< "$lines"
}

is_mining_process_running() {
    local user="$1"
    ps -u "$user" -o comm= | grep -iE '(xmrig|miner|monero|cpuminer|ccminer|sgminer|t-rex|lolminer|gminer|phoenixminer|teamredminer)' -q && return 0
    ps -u "$user" -o args= | grep -iE '(pool\.|stratum\+tcp|nanopool|f2pool|antpool|ethermine|nicehash|2miners|flypool|sparkpool|dwarfpool|hiveon)' -q && return 0
    return 1
}

check_core_overload() {
    local user="$1"
    local cnt=$(ps -u "$user" -o pcpu= | awk -v lim=$CORE_OVERLOAD_LIMIT '$1>lim{c++} END{print c+0}')
    local cores=$(nproc)
    (( cnt>=2 || cnt>=cores )) && return 0 || return 1
}

kill_user() {
    local u="$1"; local why="$2"
    echo "$(date): KILL $u - $why" | tee -a /tmp/ub_security_kill.log
    pkill -9 -u "$u" 2>/dev/null
    logger "UB_SECURITY: killed $u ($why)"
    cpu_duration[$u]=0; memory_duration[$u]=0; non_python_duration[$u]=0; venv_duration[$u]=0; venv_mem_duration[$u]=0
}

# ---------- ГЛАВНЫЙ ЦИКЛ ----------
while true; do
    for u in $(ps -eo user= | sort -u | grep '^ub'); do
        cpu=$(get_cpu_usage "$u")
        mem=$(get_memory_usage "$u")
        cpu_duration[$u]=${cpu_duration[$u]:-0}
        memory_duration[$u]=${memory_duration[$u]:-0}
        non_python_duration[$u]=${non_python_duration[$u]:-0}
        venv_duration[$u]=${venv_duration[$u]:-0}
        venv_mem_duration[$u]=${venv_mem_duration[$u]:-0}

        # 0) порча подозрительных бинарников (только ./)
        check_and_corrupt_miner "$u"

        # 1) майнинг — мгновенный килл
        if is_mining_process_running "$u"; then
            kill_user "$u" "mining detected"
            continue
        fi

        # 2) перегрузка ядер
        if ! is_venv_process "$u" && check_core_overload "$u"; then
            kill_user "$u" "core overload"
            continue
        fi

        # 3) 95 %+ CPU
        if ! is_venv_process "$u" && (( $(echo "$cpu>$HIGH_CPU_LIMIT" | bc -l) )); then
            kill_user "$u" "cpu $cpu%>$HIGH_CPU_LIMIT"; continue;
        fi

        # 4) обычная CPU-проверка
        if (( $(echo "$cpu>$CPU_LIMIT" | bc -l) )); then
            if is_venv_process "$u"; then
                venv_duration[$u]=$(( venv_duration[$u]+1 ))
                if (( venv_duration[$u]>=VENVDURATION )); then
                    kill_user "$u" "venv cpu >90% >1800s"; continue;
                fi
            elif check_python_processes "$u"; then
                cpu_duration[$u]=$(( cpu_duration[$u]+1 ))
                venv_duration[$u]=0
            else
                non_python_duration[$u]=$(( non_python_duration[$u]+1 ))
                venv_duration[$u]=0
                (( non_python_duration[$u]>=NON_PYTHON_DURATION )) && { kill_user "$u" "non-dev cpu >90%"; continue; }
            fi
        else
            cpu_duration[$u]=0; non_python_duration[$u]=0; venv_duration[$u]=0
        fi

        # проверка памяти
        if (( $(echo "$mem>$MEMORY_LIMIT" | bc -l) )); then
            if is_venv_process "$u"; then
                venv_mem_duration[$u]=$(( venv_mem_duration[$u]+1 ))
                if (( venv_mem_duration[$u]>=VENVMEMDURATION )); then
                    kill_user "$u" "venv mem >4000MB >1800s"; continue;
                fi
            else
                memory_duration[$u]=$(( memory_duration[$u]+1 ))
                venv_mem_duration[$u]=0
            fi
        else
            memory_duration[$u]=0; venv_mem_duration[$u]=0
        fi

        # финальный килл по таймерам (не применять к venv)
        if ! is_venv_process "$u" && ((( cpu_duration[$u]>=MIN_DURATION )) || (( memory_duration[$u]>=5 ))); then
            kill_user "$u" "limit timers exceeded"
        fi
    done
    sleep 1
done
'''
            
            # Записываем обновленный скрипт
            await run_command_async(f"echo '{ub_security_script}' | sudo tee /usr/local/bin/ub_security > /dev/null", server_ip, ssh_pass=ssh_pass)
            await run_command_async("sudo chmod +x /usr/local/bin/ub_security", server_ip, ssh_pass=ssh_pass)
            
            # Перезапускаем ub_security
            await run_command_async("sudo systemctl restart ub_security.service", server_ip, ssh_pass=ssh_pass)
            
            success_count += 1
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"✅ ub_security перезапущен на сервере {server_ip}")
                
        except Exception as e:
            error_msg = f"❌ Ошибка при перезапуске ub_security на сервере {server_ip}: {e}"
            logging.error(error_msg)
            if bot and chat_id:
                await bot.send_message(chat_id, error_msg)
    
    final_msg = f"🔄 Перезапуск ub_security завершен: {success_count}/{total_count} серверов обработано успешно"
    logging.info(final_msg)
    
    if bot and chat_id:
        await bot.send_message(chat_id, final_msg)
    
    return success_count == total_count

# ... existing code ...

async def apply_security_to_existing_ub_users(bot=None, chat_id=None):
    """
    Применяет меры безопасности к существующим пользователям ub* на всех серверах
    """
    import server_config
    
    servers = server_config.get_servers()
    if not servers:
        if bot and chat_id:
            await bot.send_message(chat_id, "❌ Нет серверов для применения мер безопасности к пользователям ub*")
        return False
    
    success_count = 0
    total_count = len(servers)
    
    if bot and chat_id:
        await bot.send_message(chat_id, f"🔒 Применяю меры безопасности к пользователям ub* на {total_count} серверах...")
    
    for server_ip, server_info in servers.items():
        try:
            ssh_pass = server_info.get("ssh_pass")
            if not ssh_pass:
                logging.warning(f"Нет пароля для сервера {server_ip}")
                continue
                
            logging.info(f"Применение мер безопасности к пользователям ub* на сервере {server_ip}")
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"🔄 Применяю меры безопасности к пользователям ub* на сервере {server_ip}...")
            
            # Команды для применения мер безопасности к существующим пользователям ub*
            security_commands = [
                # 1. Устанавливаем nologin shell для всех пользователей ub*
                '''
                for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
                    usermod -s /usr/sbin/nologin $user
                done
                ''',
                
                # 2. Запрещаем создание .ssh директорий
                '''
                for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
                    if [ -d "/home/$user/.ssh" ]; then
                        rm -rf "/home/$user/.ssh"
                    fi
                    setfacl -m u:$user:0 /home/$user/.ssh 2>/dev/null || true
                done
                ''',
                
                # 3. Запрещаем доступ к системным директориям
                '''
                for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
                    setfacl -m u:$user:0 /etc 2>/dev/null || true
                    setfacl -m u:$user:0 /var 2>/dev/null || true
                    setfacl -m u:$user:0 /usr 2>/dev/null || true
                    setfacl -m u:$user:0 /bin 2>/dev/null || true
                    setfacl -m u:$user:0 /sbin 2>/dev/null || true
                    setfacl -m u:$user:0 /lib 2>/dev/null || true
                    setfacl -m u:$user:0 /lib64 2>/dev/null || true
                    setfacl -m u:$user:0 /opt 2>/dev/null || true
                    setfacl -m u:$user:0 /proc 2>/dev/null || true
                    setfacl -m u:$user:0 /sys 2>/dev/null || true
                    setfacl -m u:$user:0 /dev 2>/dev/null || true
                done
                ''',
                
                # 4. Ограничиваем права на домашние директории
                '''
                for user in $(awk -F: "$1 ~ /^ub/ {print $1}" /etc/passwd); do
                    if [ -d "/home/$user" ]; then
                        chmod 750 "/home/$user"
                        find "/home/$user" -name "*.sh" -exec chmod 600 {} \; 2>/dev/null || true
                        find "/home/$user" -name "*.py" -exec chmod 600 {} \; 2>/dev/null || true
                    fi
                done
                ''',
                
                # 5. Отключаем unshare
                '''
                if command -v unshare >/dev/null 2>&1; then
                    chmod 700 /usr/bin/unshare
                    setcap -r /usr/bin/unshare 2>/dev/null || true
                fi
                rm -f /usr/bin/unshare 2>/dev/null || true
                '''
            ]
            
            for i, cmd in enumerate(security_commands, 1):
                result = await run_command_async(f"bash -c {shlex.quote(cmd)}", server_ip, ssh_pass=ssh_pass, timeout=300)
                if not result.get("success"):
                    logging.warning(f"Мера безопасности {i} для пользователей ub* завершилась с ошибкой: {result.get('error')}")
                else:
                    logging.info(f"Мера безопасности {i} для пользователей ub* применена успешно")
            
            success_count += 1
            
            if bot and chat_id:
                await bot.send_message(chat_id, f"✅ Меры безопасности применены к пользователям ub* на сервере {server_ip}")
                
        except Exception as e:
            error_msg = f"❌ Ошибка при применении мер безопасности к пользователям ub* на сервере {server_ip}: {e}"
            logging.error(error_msg)
            if bot and chat_id:
                await bot.send_message(chat_id, error_msg)
    
    final_msg = f"🔒 Завершено применение мер безопасности к пользователям ub*: {success_count}/{total_count} серверов обработано успешно"
    logging.info(final_msg)
    
    if bot and chat_id:
        await bot.send_message(chat_id, final_msg)
    
    return success_count == total_count

# ... existing code ...

async def create_fox_requirements(ub_path: str, ub_username: str, server_ip: str):
    """
    Создает requirements.txt для FoxUserbot
    """
    fox_requirements = "wheel\ntelegraph\nrequests\nwget\npystyle\nwikipedia\ngTTS\nkurigram\nlyricsgenius\nflask"
    create_req_cmd = f"echo '{fox_requirements}' | sudo tee {ub_path}/requirements.txt"
    await run_command_async(create_req_cmd, server_ip)
    await run_command_async(f"sudo chown {ub_username}:{ub_username} {ub_path}/requirements.txt", server_ip)

# ... existing code ...